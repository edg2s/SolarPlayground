<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='sp-Scenario'>/**
</span> * Solar playground scenario container
 *
 * @class
 * @mixins OO.EventEmitter
 *
 * @param {JQuery} $canvas Target canvas for the scenario
 * @param {Object} scenario Scenario configuration object
 */
sp.Scenario = function SpScenario( $canvas, scenario ) {
	var objects;

	// Mixin constructors
	OO.EventEmitter.call( this );

	// TODO: Validate the scenario object to make sure all required
	// elements exist.

	// TODO: Create another canvas for trails so we can visualize the
	// orbits with trails that remain for a bit on the screen
	this.$canvas = $canvas;
	this.context = $canvas[0].getContext( &#39;2d&#39; );

	this.paused = false;
	this.objects = {};

	// Prepare general configuration
	this.config = scenario.config || {};

	// Viewpoint controller
	this.viewpoint = new sp.Viewpoint( {
		&#39;zoom&#39;: this.config.init_zoom || 1,
		&#39;centerPoint&#39;: {
			x: this.$canvas.width() / 2,
			y: this.$canvas.height() / 2
		},
		&#39;yaw&#39;: 0,
		&#39;pitch&#39;: 0,
		&#39;scale&#39;: {
			&#39;orbit&#39;: this.config.orbit_scale || 0.5 * Math.pow( 10, -5 ),
			&#39;planets&#39;: this.config.planet_scale
		}
	} );

	this.showTrails = this.config.show_trails || false;

	this.pov_key = this.config.init_pov;
	this.pov_object = null;

	this.date = this.config.start_time || { day: 1, month: 1, year: 2000 };
	this.time = 0;
	this.speed = this.config.init_speed || 1;

	// Prepare the objects
	this.processObjects( scenario.objects || {} );
};

/* Inheritance */
OO.mixinClass( sp.Scenario, OO.EventEmitter );

<span id='sp-Scenario-method-processObjects'>/**
</span> * Process the solar playground simulator objects
 * @param {Object} scenarioObjects Simulation objects definition
 */
sp.Scenario.prototype.processObjects = function ( scenarioObjects ) {
	var o, co, radii_diff, step_size, radius, circle_radius, smallest_radii,
		radii = {
			&#39;star&#39;: [],
			&#39;planet&#39;: []
		};

	// Initialize celestial objects
	for ( o in scenarioObjects ) {
		this.objects[o] = new sp.Scenario.CelestialObject( scenarioObjects[o] );

		// Collect all radii
		if ( scenarioObjects[o].vars.r ) {
			if ( scenarioObjects[o].type === &#39;star&#39; ) {
				radii[&#39;star&#39;].push( Number( scenarioObjects[o].vars.r ) );
			} else {
				radii[&#39;planet&#39;].push( Number( scenarioObjects[o].vars.r ) );
			}
		}
	}

	// Send the radii list to the viewpoint
	this.viewpoint.setRadiiList( radii );

	// Figure out which objects orbit what
	for ( co in this.objects ) {
		if ( scenarioObjects[co] &amp;&amp; this.objects[scenarioObjects[co].orbiting] ) {
			// Connect the object to its center of orbit
			this.objects[co].setOrbit( this.objects[scenarioObjects[co].orbiting] );
		}
	}

	// Set initial POV
	if ( this.pov_key &amp;&amp; this.objects[this.pov_key] ) {
		this.pov_object = this.objects[this.pov_key];
		this.viewpoint.setPOV( this.objects[this.pov_key].getSpaceCoordinates( 0 ) );
	}
};

<span id='sp-Scenario-method-draw'>/**
</span> * Draw all elements
 * @param {number} time Time
 */
sp.Scenario.prototype.draw = function ( time ) {
	var o, coords, viewpointCoords, view, radius, trails;

	for ( o in this.objects ) {
		coords = this.objects[o].getSpaceCoordinates( time );

		// Update POV coordinates
		if ( o === this.pov_key ) {
			this.viewpoint.setPOV( coords );
		}
		// Translate coordinates to canvas
		viewpointCoords = this.viewpoint.getCoordinates( coords );

		if ( viewpointCoords ) {
			// Get graphic details
			view = this.objects[o].getView();

			// TODO: Allow the user to choose between relative radii and preset radius value
			// in the view parameters, instead of having the view take precedence randomly
			radius = this.viewpoint.getRadius( this.objects[o].getRadius(), this.objects[o].getType() );

			// Draw
			this.drawCircle( this.context,
				viewpointCoords,
				radius,
				view.color,
				// Add a shadow to stars
				this.objects[o].getType() === &#39;star&#39;
			);

			// Draw planet trails
			if ( this.showTrails ) {
				// Get the trail points
				trails = this.objects[o].getTrailPoints();
				for ( i = 0; i &lt; trails.length; i++ ) {
					// Draw all trails as dots
					this.drawCircle(
						this.context,
						this.viewpoint.getCoordinates( trails[i] ),
						1,
						// TODO: Consider making trail colors a configuration option
						&#39;#FF005D&#39; // Bright pink
					);
				}
			}
		}
	}
};

<span id='sp-Scenario-method-drawCircle'>/**
</span> * Draw a circle on the canvas
 * @param {Object} context Canvas context object
 * @param {Object} coords Canvas coordinates
 * @param {number} [radius] Circle radius
 * @param {string} [color] Circle color
 * @param {boolean} [hasShadow] Add a shadow
 */
sp.Scenario.prototype.drawCircle = function ( context, coords, radius, color, hasShadow ) {
	context.save();
	context.beginPath();
	context.arc(
		coords.x,
		coords.y,
		radius || 5, 0, 2 * Math.PI,
		false
	);
	context.fillStyle = color || &#39;white&#39;;
	if ( hasShadow ) {
		context.shadowColor = color || &#39;white&#39;;
		context.shadowBlur = 20;
		context.shadowOffsetX = 0;
		context.shadowOffsetY = 0;
	}
	context.fill();
	context.restore();
};

<span id='sp-Scenario-method-clearCanvas'>/**
</span> * Clear an area on the canvas
 * @param {Object} context Canvas context object
 * @param {number} [square] Dimensions and coordinates of the square
 * to clear
 * @param {number} [square.top] Top coordinate of the square
 * @param {number} [square.left] Left coordinate of the square
 * @param {number} [square.width] Width of the square
 * @param {number} [square.height] Height of the square
 */
sp.Scenario.prototype.clearCanvas = function ( context, square ) {
	context = this.context;
	square = square || {};

	// Fix optional values:
	square.left = square.left || 0;
	square.top = square.top || 0;
	square.width = square.width || this.$canvas.width();
	square.height = square.height || this.$canvas.height();

	// Erase the square
	context.clearRect( square.left, square.top, square.width, square.height );
};

<span id='sp-Scenario-method-run'>/**
</span> * Run the scenario
 */
sp.Scenario.prototype.run = function () {
	if ( !this.paused ) {
		// Clear canvas
		this.clearCanvas( this.context );

		// Draw canvas
		this.draw( this.time );

		// Increase time
		this.time += 0.0000000001 * this.speed;

		window.requestNextAnimationFrame( $.proxy( this.run, this ) );
	}
};

<span id='sp-Scenario-method-togglePaused'>/**
</span> * Toggle between pause and resume the scenario
 * @param {boolean} [isPause] Optional. If supplied, pauses or resumes the scenario
 */
sp.Scenario.prototype.togglePaused = function ( isPause ) {
	isPause = !!isPause || !this.paused;
	this.paused = isPause;
	this.run();
};

<span id='sp-Scenario-method-isPaused'>/**
</span> * Check whether the scenario is paused
 */
sp.Scenario.prototype.isPaused = function () {
	return this.paused;
};

<span id='sp-Scenario-method-pause'>/**
</span> * Pause the scenario
 */
sp.Scenario.prototype.pause = function () {
	this.paused = true;
};

<span id='sp-Scenario-method-resume'>/**
</span> * Resume the scenario
 */
sp.Scenario.prototype.resume = function () {
	this.paused = false;
	this.run();
};
</pre>
</body>
</html>
