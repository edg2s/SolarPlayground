<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='sp-Container'>/**
</span> * Solar Playground container
 *
 * @class sp.Container
 * @mixins OO.EventEmitter
 *
 * @param {Object} [config] Configuration object
 */
sp.Container = function SpContainer( config ) {
	// Mixin constructors
	OO.EventEmitter.call( this );

	this.config = config || {};
	this.scenario = null;

	// Initialize
	this.$container = $( config.container )
		.addClass( &#39;sp-container&#39; )

	this.$canvas = $( &#39;&lt;canvas&gt;&#39; )
		.addClass( &#39;sp-container-canvas&#39; )
		.attr( &#39;width&#39;, config.width )
		.attr( &#39;height&#39;, config.height )
		.appendTo( this.$container );

	// Gui
	guiLoader = new sp.Gui.Loader( {
		&#39;module&#39;: &#39;ooui&#39;,
		&#39;container&#39;: this
	} );
	this.gui = guiLoader.initialize();

	this.canvasMouseMoving = false;
	this.canvasMouseStartPosition = {};

	// Events
	this.gui.connect( this, { &#39;play&#39;: &#39;onGuiPlay&#39; } );
	this.gui.connect( this, { &#39;zoom&#39;: &#39;onGuiZoom&#39; } );
	this.gui.connect( this, { &#39;pov&#39;: &#39;onGuiPOV&#39; } );

	this.$canvas.on( &#39;mousedown&#39;, $.proxy( this.onCanvasMouseDown, this ) );
	this.$canvas.on( &#39;mousemove&#39;, $.proxy( this.onCanvasMouseMove, this ) );
	this.$canvas.on( &#39;mouseup&#39;, $.proxy( this.onCanvasMouseUp, this ) );
	this.$canvas.on( &#39;mouseout&#39;, $.proxy( this.onCanvasMouseUp, this ) );
};

/* Inheritance */
OO.mixinClass( sp.Container, OO.EventEmitter );

<span id='sp-Container-event-scenarioLoaded'>/**
</span> * @event scenarioLoaded
 * @param {sp.Scenario} scenario Reference to the loaded scenario
 * Scenario fully loaded and ready to be run.
 */

/* Methods */

<span id='sp-Container-method-loadFromFile'>/**
</span> * Load a scenario
 * @param {String} scenarioName Scenario name. The system will search for
 *  an ajax response from source &#39;scenario.[name].json&#39; in the scenario
 *  directory.
 * @chainable
 */
sp.Container.prototype.loadFromFile = function ( scenarioName ) {
	var targetName,
		targetDir = this.config.scenario_dir + this.config.directory_sep;

	scenarioName = scenarioName || &#39;example&#39;;
	targetName = &#39;scenario.&#39; + scenarioName + &#39;.json&#39;;

	$.getJSON( targetDir + targetName )
		.done( $.proxy( function ( response ) {
			// Load the scenario
			this.loadFromObject( response );
		}, this ) )
		.fail( function () {
			sp.log( &#39;Error&#39;, &#39;Scenario &#39; + targetName + &#39; not found in directory &quot;&#39; + targetDir + &#39;&quot;&#39; );
		} );
};

<span id='sp-Container-method-loadFromObject'>/**
</span> * Load and run a scenario
 * @param {Object} scenarioObject Scenario configuration object
 * @chainable
 * @fires scenarioLoaded
 */
sp.Container.prototype.loadFromObject = function ( scenarioObject ) {
	var objList;

	scenarioObject = scenarioObject || {};

	this.scenario = new sp.Scenario( this, scenarioObject );
	// Link scenario to GUI
	this.gui.setScenario( this.scenario );

	// Draw initial frame
	this.scenario.draw( 0 );

	// Add pov objects to gui
	objList = this.scenario.getAllObjects();
	for ( o in objList ) {
		this.gui.addToPOVList(
			o,
			objList[o].getName()
		);
	}

	this.emit( &#39;scenarioLoaded&#39;, this.scenario );
	return this;
};

<span id='sp-Container-method-onGuiPlay'>/**
</span> * Respond to play button press
 * @param {Boolean} isPlay Play or pause
 */
sp.Container.prototype.onGuiPlay = function ( isPlay ) {
	this.scenario.togglePaused( !isPlay );
};

<span id='sp-Container-method-onGuiZoom'>/**
</span> * Respond to zoom button press
 * @param {Boolean} zoom Zoom level
 */
sp.Container.prototype.onGuiZoom = function ( zoom ) {
	this.scenario.setZoom( zoom );
};

<span id='sp-Container-method-onGuiPOV'>/**
</span> * Respond to pov button press
 * @param {Boolean} newPov New POV object key
 */
sp.Container.prototype.onGuiPOV = function ( newPov ) {
	this.scenario.setPOV( newPov );
};

<span id='sp-Container-method-onCanvasMouseDown'>/**
</span> * Propogate canvas mousedown event
 * @param {Event} e Event
 * @fires mousedown
 */
sp.Container.prototype.onCanvasMouseDown = function ( e ) {
	this.canvasMouseMoving = true;
	this.mouseStartingPoint = {
		&#39;x&#39;: e.pageX,
		&#39;y&#39;: e.pageY
	};
	if ( this.scenario ) {
		this.scenarioCenterPoint = this.scenario.getCenterPoint();
	}
};

<span id='sp-Container-method-onCanvasMouseMove'>/**
</span> * Respond to canvas mouse move
 * @param {Event} e Event
 * @fires canvasdrag
 */
sp.Container.prototype.onCanvasMouseMove = function ( e ) {
	if ( this.canvasMouseMoving &amp;&amp; !$.isEmptyObject( this.mouseStartingPoint ) ) {
		dx = e.pageX - this.mouseStartingPoint.x;
		dy = e.pageY - this.mouseStartingPoint.y;

		this.scenario.setCenterPoint(
			dx + this.scenarioCenterPoint.x,
			dy + this.scenarioCenterPoint.y
		);

		this.scenario.flushAllTrails();
		this.scenario.clearCanvas();
		this.scenario.draw();
	}
};

<span id='sp-Container-method-onCanvasMouseUp'>/**
</span> * Propogate canvas mouseup event
 * @param {Event} e Event
 */
sp.Container.prototype.onCanvasMouseUp = function ( e ) {
	this.canvasMouseMoving = false;
	this.mouseStartingPoint = {};
	this.scenarioCenterPoint = {};
};

<span id='sp-Container-method-addToolbar'>/**
</span> * Add a toolbar to the container
 * @param {jQuery} $toolbar jQuery toolbar element
 * @param {string} [position] Position in the container; &#39;top&#39; or &#39;bottom&#39;
 */
sp.Container.prototype.addToolbar = function ( $toolbar, position ) {
	position = position || &#39;top&#39;;

	if ( position === &#39;top&#39; ) {
		this.$container.prepend( $toolbar );
	} else {
		this.$container.append( $toolbar );
	}
};

<span id='sp-Container-method-getContext'>/**
</span> * Get the canvas context
 * @returns {Object} Canvas context
 */
sp.Container.prototype.getContext = function () {
	return this.$canvas[0].getContext( &#39;2d&#39; );
};

<span id='sp-Container-method-getCanvasDimensions'>/**
</span> * Get the canvas dimensions
 * @returns {Object} Width and height of the canvas
 */
sp.Container.prototype.getCanvasDimensions = function () {
	return {
		&#39;width&#39;: this.$canvas.width(),
		&#39;height&#39;: this.$canvas.height()
	}
};

<span id='sp-Container-method-setScenario'>/**
</span> * Attach scenario object to this container
 * @param {sp.Scenario} s Scenario object
 */
sp.Container.prototype.setScenario = function ( s ) {
	this.scenario = s;
};

<span id='sp-Container-method-togglePaused'>/**
</span> * Toggle between pause and resume the scenario
 * @param {boolean} [isPause] Optional. If supplied, pauses or resumes the scenario
 */
sp.Container.prototype.togglePaused = function ( isPause ) {
	this.scenario.togglePaused( isPause );
};

<span id='sp-Container-method-setZoom'>/**
</span> * Set scenario zoom
 * @param {number} zoom Zoom factor
 */
sp.Container.prototype.setZoom = function ( zoom ) {
	this.scenario.setZoom( zoom );
};

<span id='sp-Container-method-isPaused'>/**
</span> * Check whether the scenario is paused
 */
sp.Container.prototype.isPaused = function () {
	return this.scenario.isPaused();
};
</pre>
</body>
</html>
