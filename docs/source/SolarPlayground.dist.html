<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * SolarPlayground - The adaptive javascript-based solar
 * system simulator.
 *
 * @author Moriel Schottlender
 *
 * Define an easily accessed global namespace for the
 * Solar Playground system.
 */
( function () {
<span id='global-property-solarPlayground'>	/**
</span>	 * Definition of the namespace with its sub-namespaces
	 * @property {Object}
	 */
	var solarPlayground = {
		&#39;container&#39;: {
			&#39;elements&#39;: {}
		},
		&#39;data&#39;: {
			&#39;items&#39;: {}
		},
		&#39;calc&#39;: {},
		&#39;view&#39;: {},
		&#39;ui&#39;: {
			&#39;ext&#39;: {}
		}
	};

<span id='global-method-log'>	/**
</span>	 * General method to produce logs into the console
	 * or some files.
	 *
	 * @param {String} type Message type: LOG, ERROR
	 * @param {String} msg Log message
	 */
	solarPlayground.log = function SpLog( type, msg ) {
		type = type || &#39;LOG&#39;;
		// TODO: Condition the console logging only on debug mode
		// otherwise output logs to a file
		window.console.log( &#39;[&#39; + type + &#39;] &#39; + msg );
	};

	// Add to the global namespace
	window.sp = solarPlayground;
} )();

/*
 * Animation requestNextAnimationFrame based on available
 * technology in the browser.
 *
 * Copyright (C) 2012 David Geary. This code is from the book
 * Core HTML5 Canvas, published by Prentice-Hall in 2012.
 *
 * License:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation files
 * (the &quot;Software&quot;), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * The Software may not be used to create training material of any sort,
 * including courses, books, instructional videos, presentations, etc.
 * without the express written consent of David Geary.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
*/

window.requestNextAnimationFrame = ( function () {
	var originalWebkitRequestAnimationFrame = undefined,
		wrapper = undefined,
		callback = undefined,
		geckoVersion = 0,
		userAgent = navigator.userAgent,
		index = 0,
		self = this;

		// Workaround for Chrome 10 bug where Chrome
		// does not pass the time to the animation function

	if ( window.webkitRequestAnimationFrame ) {
		// Define the wrapper
		wrapper = function (time) {
			if (time === undefined) {
				time += new Date();
			}
			self.callback(time);
		};

		// Make the switch
		originalWebkitRequestAnimationFrame = window.webkitRequestAnimationFrame;

		window.webkitRequestAnimationFrame = function ( callback, element ) {
			self.callback = callback;

			// Browser calls the wrapper and wrapper calls the callback
			originalWebkitRequestAnimationFrame( wrapper, element );
		}
	}

	// Workaround for Gecko 2.0, which has a bug in
	// mozRequestAnimationFrame() that restricts animations
	// to 30-40 fps.

	if ( window.mozRequestAnimationFrame ) {
		// Check the Gecko version. Gecko is used by browsers
		// other than Firefox. Gecko 2.0 corresponds to
		// Firefox 4.0.
		index = userAgent.indexOf( &#39;rv:&#39; );

		if ( userAgent.indexOf( &#39;Gecko&#39; ) != -1) {
			geckoVersion = userAgent.substr( index + 3, 3 );

			if ( geckoVersion === &#39;2.0&#39; ) {
				// Forces the return statement to fall through
				// to the setTimeout() function.
				window.mozRequestAnimationFrame = undefined;
			}
		}
	}

	return window.requestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame ||
		window.msRequestAnimationFrame ||
		function ( callback, element ) {
			var start,
				finish;

			window.setTimeout( function () {
				start += new Date();
				callback( start );
				finish += new Date();

				self.timeout = 1000 / 60 - ( finish - start );
			}, self.timeout );
		};
} ) ();

<span id='sp-System'>/**
</span> * Solar Playground main system controller
 *
 * @class sp.System
 * @mixins OO.EventEmitter
 *
 * @param {Object} [config] Configuration object
 */
sp.System = function SpSystem( config ) {
	var defaultConfig;

	// Mixin constructors
	OO.EventEmitter.call( this );

	// Containers holder
	this.containers = {};

	config = config || {};

	defaultConfig = {
		scenario_dir: &#39;scenarios&#39;, // Default directory unless otherwise specified
		scenario_prefix: &#39;scenario.&#39;, // Default scenario file prefix
		directory_sep: &#39;/&#39;,
		width: $( window ).width() - 100,
		height: $( window ).height() - 100
	};

	// Extend default global options
	this.config = $.extend( true, defaultConfig, config );
};

/* Inheritance */
OO.mixinClass( sp.System, OO.EventEmitter );

/* Methods */

<span id='sp-System-method-setContainer'>/**
</span> * Add a container
 * @param {string} container_id The id of the DOM that this container
 * will be attached to
 * @param {Object} [config] Configuration object
 * @chainable
 * @throws {Error} If container_id is undefined or empty
 * @return {sp.Container} The new container
 */
sp.System.prototype.setContainer = function ( container_id, config ) {
	if ( !container_id ) {
		throw Error( &#39;sp.System.setContainer must supply a valid container_id.&#39; );
	}

	// Add a container
	this.containers[container_id] = new sp.container.Manager( {
		&#39;container&#39;: &#39;#&#39; + container_id,
		&#39;width&#39;: config.width || this.config.width,
		&#39;height&#39;: config.height || this.config.height,
		&#39;gui&#39;: config.gui || &#39;ooui&#39;,
		scenario_dir: this.config.scenario_dir,
		directory_sep: this.config.directory_sep,
		scenario_prefix: config.scenario_prefix || this.config.scenario_prefix,
		// TODO: When &#39;build&#39; mode is created, it should be either
		// enabled right on instantiation or allow to be added later
		buildMode: false
	} );

	return this.containers[container_id];
};

<span id='sp-System-method-getContainer'>/**
</span> * Retrueve the container by its id
 * @param {string} container_id The id of the DOM that this container
 * is attached to
 * @throws {Error} If there are no containers defined
 * @returns {sp.Container|null} The container
 */
sp.System.prototype.getContainer = function ( container_id ) {
	if ( !this.containers ) {
		throw Error( &#39;Cannot get container, no containers are defined.&#39; );
	}
	return this.containers[container_id];
};

<span id='sp-System-method-getConfig'>/**
</span> * Get configuration option or full configuration object.
 * @param {string} [option] Configuration key
 * @returns {string|Object} Configuration object
 */
sp.System.prototype.getConfig = function ( option ) {
	if ( this.config &amp;&amp; option ) {
		return this.config[option];
	}
	return this.config;
};

<span id='sp-calc-Calculator'>/**
</span> * Solar Playground calculator. Contains methods for calculations across the scenarios.
 *
 * @class sp.calc.Calculator
 *
 * @param {Object} [config] Configuration object
 */
sp.calc.Calculator = function SpScenarioCalculator( config ) {};

<span id='sp-calc-Calculator-property-constants'>/**
</span> * Astronomical constants. Mostly related to the solar
 * system but also to other calculations.
 * @property {Object}
 */
sp.calc.Calculator.constants = {
	// Astronomical units (AU) in km
	&#39;AU&#39;: 149597871, // km
	// Gravitational constant in N*(m/kg)^2
	&#39;G&#39;: 6.67 * Math.pow( 10, -11 )
};

<span id='sp-calc-Calculator-method-translateTime'>/**
</span> * Calculate the absolute time needed for proper calculations.
 * In our case, it is the number of days from 1999 Dec 31, 0:00 UT
 * @param {number} year Requested year (YYYY)
 * @param {number} month Requested month
 * @param {number} day Requested day of the month
 * @param {number} time_of_day Time of day in decimals 0-24
 * @returns {number} The decimal number of days from 1999 Dec 31, 0:00 UT
 */
sp.calc.Calculator.translateTime = function ( year, month, day, time_of_day ) {
	var totalDays;
	year = year || 2014;
	month = month || 6;
	day = day || 10;
	time_of_day = time_of_day || 0;

	// The day calculation must be integer calculation, so &#39;Math.floor&#39; must
	// be used for all divisions
	totalDays = 367 * year - 7 *
		Math.floor( ( year + Math.floor( ( month + 9 ) / 12 ) ) / 4 ) +
		275 * Math.floor( month / 9 ) + D - 730530;

	// Add time (floating point division)
	totalDays += time_of_day / 24;

	return totalDays;
};

<span id='sp-calc-Calculator-method-getCenturies'>/**
</span> * Translate date to th enumber of centuries from J2000.0
 * @param {number} year Requested year (yyyy)
 * @param {number} [month] Requested month
 * @param {number} [day] Requested day of the month
 * @param {number} [hours] Hour of the day in 24h format
 * @param {number} [minutes] Minutes after the hour
 * @param {number} [seconds] Seconds after the minute
 * @returns {number} Number of centuries from epoch J2000.0
 */
sp.calc.Calculator.getCenturies = function ( year, month, day, hours, minutes, seconds ) {
	var D,
		h = hour + minutes / 60 + second / 3600;

	day = day || 1;
	month = month || 1;

	D = 367 * year - 7 * Math.floor( ( year + Math.floor( ( month + 9 ) / 12 ) ) / 4 ) + day - 730531.5 + h / 24;

	return D / 36525;
};

<span id='sp-calc-Calculator-method-getJDNTime'>/**
</span> * Return a JDN (Julian Day Number) from J2000.0, converted from a Gregorian date and time
 * @param {number} year Requested year (yyyy)
 * @param {number} month Requested month
 * @param {number} day Requested day of the month
 * @param {number} [hours] Hour of the day in 24h format
 * @param {number} [minutes] Minutes after the hour
 * @param {number} [seconds] Seconds after the minute
 * @returns {number} JDN, number of days from epoch J2000.0
 */
sp.calc.Calculator.getJDNTime = function ( year, month, day, hours, minutes, seconds ) {
	var JDN,
		a = Math.floor( ( 14 - month ) / 12 ),
		y = year + 4800 - a,
		m = month + 12 * a - 3;

	hours = hours || 12; // Given hours or midday
	minutes = minutes || 0;
	seconds = seconds || 0;

	// Translate from Gregorian to JDN
	// Calculation take from
	// https://en.wikipedia.org/wiki/Julian_day#Converting_Julian_or_Gregorian_calendar_date_to_Julian_Day_Number
	JDN = day + Math.floor( ( 153 * m + 2) / 5 ) + 365 * y +
		Math.floor( y / 4 ) - Math.floor( y / 100 ) + Math.floor( y / 400 ) +
		32045

	// Include time of day
	JD = JDN + ( ( hours - 12 ) / 24 ) + ( minutes / 1440 ) + ( seconds / 86400 );

	// Return JD from J2000.0 (Epoch)
	return JD - 2451545.0;
};

<span id='sp-calc-Calculator-method-solveKepler'>/**
</span> * Solve the Kepler equation for the given parameters to get the object&#39;s
 * position in space. This position is raw heliocentric space coordiates
 *
 * Calculation taken from NASA JPL Formula:
 * http://ssd.jpl.nasa.gov/?planet_pos
 * And
 * https://gist.github.com/bartolsthoorn/7913357
 *
 * @param {Object} vars Variables necessary for calculation.
 * @param {number[]} vars.a Semi-major axis (au and au/cy)
 * @param {number[]} vars.e Eccentricity ( no units and no units/cy)
 * @param {number[]} vars.I Inclination (degrees and degrees/cy)
 * @param {number[]} vars.L Mean longitude (degrees and degrees/cy)
 * @param {number[]} vars.long_peri Longitude of perihelion (degree and degrees/cy)
 * @param {number[]} vars.long_node Longitude of the ascending node (degrees and degrees/cy)
 * @param {number} [jd] Julian Days from J2000.0. If not given, calculated for J2000.0
 * @returns {Object} Three-dimensional position in space, values in km
 */
sp.calc.Calculator.solveKepler = function ( vars, jd ) {
	var T, a, e, I, L, om, bigOm, omega, M, b, c, f, s,
		dimensions = {},
		x_tag, y_tag, z_tag,
		ITERLIMIT = 1000,
		ERRORLIMIT = Math.pow( 10, -4 ),
<span id='sp-calc-Calculator-method-'>		/**
</span>		 * Convert angles to radians
		 * @param {number} angle Angle
		 * @returns {number} Radians
		 */
		to_radians = function toRadians( angle ) {
			return angle * ( 180 / Math.PI );
		},
<span id='sp-calc-Calculator-method-'>		/**
</span>		 * Approximate the eccententric anomaly by iteration
		 * @param {number} e Eccentricity
		 * @param {number} M Mean anomaly
		 * @returns {number} Eccentric anomaly in radians
		 */
		approximate_E = function approxE( e, M ) {
			var e_star = ( Math.PI / 180 ) * e,
			E_n = M + e_star + Math.sin( to_radians( M ) ),
			dE = 1,
			i = 0;

			while ( ITERLIMIT-- &amp;&amp; Math.abs( dE ) &gt; ERRORLIMIT ) {
				dM = M - ( E_n - e_star * Math.sin( to_radians( E_n ) ) );
				dE = dM / ( 1 - e * Math.cos( to_radians( E_n ) ) );
				E_n = E_n + dE;
			}
			return to_radians( E_n );
		};

	if ( !vars ) {
		return null;
	}

	// Optional variables
	T = jd || 0;
	b = vars.b || 0;
	c = vars.c || 0;
	f = vars.f || 0;
	s = vars.s || 0;

	// Calculate the elements
	a = vars.a[0] + vars.a[1] * T;
	e = vars.e[0] + vars.e[1] * T;
	I = vars.I[0] + vars.I[1] * T;
	L = vars.L[0] + vars.L[1] * T;
	om = vars.long_peri[0] + vars.long_peri[1] * T;
	bigOm = vars.long_node[0] + vars.long_node[1] * T;

	// Argument of perihelion
	omega = om - bigOm;

	// Mean anomaly
	M = vars.M || L - om + b *
		Math.pow( T, 2 ) + c * Math.cos( f * T ) + s * Math.sin( f * T );
	M = to_radians( M ) % 180;

	// Eccentric anomaly
	E = approximate_E( e, M );

	// Heliocentric coordinates
	x = a * ( Math.cos( E ) - e );
	y = a * Math.sqrt( 1 - Math.pow( e, 2 ) ) * Math.sin( E );
	z = 0;

	// TODO: Figure out how to adjust to a system
	// where two or more stars are the &#39;heliocentric&#39;
	// coordinate center, like binary systems

	dimensions = {
		&#39;x&#39;: x,
		&#39;y&#39;: y,
		&#39;z&#39;: y
	};
	return dimensions;
};

<span id='sp-container-Loader'>/**
</span> * Solar Playground container scenario loader
 *
 * @class
 * @mixins OO.EventEmitter
 *
 * @param {Object} [config] Configuration object
 */
sp.container.Loader = function SpContainerLoader( config ) {
	// Mixin constructors
	OO.EventEmitter.call( this );

	this.config = config || {};
};

/* Inheritance */
OO.mixinClass( sp.container.Loader, OO.EventEmitter );

<span id='sp-container-Loader-method-loadFromFile'>/**
</span> * Load a scenario
 * @param {String} scenarioName Scenario name. The system will search for
 *  an ajax response from source &#39;scenario.[name].json&#39; in the scenario
 *  directory.
 */
sp.container.Loader.prototype.loadFromFile = function ( scenarioName, filename ) {
	var deferred = $.Deferred();

	$.getJSON( filename )
		.done( $.proxy( function ( response ) {
			deferred.resolve( response );
		}, this ) )
		.fail( function () {
			sp.log( &#39;Error&#39;, &#39;Scenario &#39; + targetName + &#39; not found in directory &quot;&#39; + targetDir + &#39;&quot;&#39; );
			deferred.reject();
		} );

	return deferred;
};

<span id='sp-container-Loader-method-loadFromObject'>/**
</span> * Load and run a scenario
 * @param {Object} scenarioObject Scenario configuration object
 * @fires scenarioLoaded
 */
sp.container.Loader.prototype.loadFromObject = function ( scenarioObject ) {
	var objList;

	// TODO: Validate the scenario object before loading

	scenarioObject = scenarioObject || {};

	scenario = new sp.data.Scenario( this, scenarioObject );
	this.setScenario( scenario );

	// Draw initial frame
//	this.scenario.draw( 0 );

	// Add pov objects to gui
	objList = this.scenario.getAllObjects();
	for ( o in objList ) {
		this.gui.addToPOVList(
			o,
			objList[o].getName()
		);
	}

	this.emit( &#39;scenarioLoaded&#39;, this.scenario );
};

<span id='sp-container-Manager'>/**
</span> * Solar Playground container manager
 *
 * @class sp.container.Manager
 * @mixins OO.EventEmitter
 *
 * @param {Object} [config] Configuration object
 */
sp.container.Manager = function SpContainerManager( config ) {
	// Mixin constructors
	OO.EventEmitter.call( this );

	this.config = config || {};
	this.scenario = null;

	// Scenario loader
	this.loader = new sp.container.Loader( config );

	this.$container = $( config.container )
		.addClass( &#39;sp-container&#39; );

	// Adjust height
	// Remove 40px for top bar
	config.height -= 40;

	// Canvas and context
	this.screen = new sp.container.Screen( config );
	this.$container.append( this.screen.$canvas );

	// Gui
	guiLoader = new sp.ui.Loader( {
		&#39;module&#39;: config.gui || &#39;ooui&#39;, // Default module
		&#39;container&#39;: this
	} );
	this.gui = guiLoader.initialize();
};

/* Inheritance */
OO.mixinClass( sp.container.Manager, OO.EventEmitter );

<span id='sp-container-Manager-event-scenarioLoaded'>/**
</span> * @event scenarioLoaded
 * @param {sp.Scenario} scenario Reference to the loaded scenario
 * Scenario fully loaded and ready to be run.
 */

/* Methods */

<span id='sp-container-Manager-method-loadFromName'>/**
</span> * Load scenario from file.
 * @param {string} scenarioName The scenario name
 * @param {Object} [overrideConfig] Optional configuration parameters
 *  that will override whatever is in the scenario file.
 * @returns {jQuery.Promise}
 */
sp.container.Manager.prototype.loadFromName = function ( scenarioName, overrideConfig ) {
	var targetName, objList,
		deferred = $.Deferred(),
		filePrefix = this.config.scenario_prefix || &#39;&#39;,
		targetDir = this.config.scenario_dir + this.config.directory_sep;

	deferred = $.Deferred();

	scenarioName = scenarioName || &#39;example&#39;;
	targetName = targetDir + filePrefix + scenarioName + &#39;.json&#39;;

	this.loader.loadFromFile( scenarioName, targetName )
		.done( $.proxy( function ( scenarioObject ) {
			scenario = new sp.data.Scenario( this.screen, scenarioObject, overrideConfig );
			this.setScenario( scenario );
			// Add pov objects to gui
			objList = this.scenario.getAllObjects();
			for ( var o in objList ) {
				this.gui.addToPOVList(
					o,
					objList[o].getName()
				);
			}
			this.emit( &#39;scenarioLoaded&#39; );
			deferred.resolve( this );
		}, this ) );

	return deferred;
};

<span id='sp-container-Manager-method-addToolbar'>/**
</span> * Add a toolbar to the container
 * @param {jQuery} $toolbar jQuery toolbar element
 * @param {string} [position] Position in the container; &#39;top&#39; or &#39;bottom&#39;
 */
sp.container.Manager.prototype.addToolbar = function ( $toolbar, position ) {
	position = position || &#39;top&#39;;

	if ( position === &#39;top&#39; ) {
		this.$container.prepend( $toolbar );
	} else {
		this.$container.append( $toolbar );
	}
};

<span id='sp-container-Manager-method-setScenario'>/**
</span> * Attach scenario object to this container
 * @param {sp.Scenario} s Scenario object
 */
sp.container.Manager.prototype.setScenario = function ( s ) {
	this.scenario = s;

	// Draw
	this.screen.clear();
	this.scenario.draw();
};

<span id='sp-container-Manager-method-getScenario'>/**
</span> * Retrieve the scenario attached to this container
 * @returns {sp.Scenario} s Scenario object
 */
sp.container.Manager.prototype.getScenario = function () {
	return this.scenario;
};

<span id='sp-container-Manager-method-togglePaused'>/**
</span> * Toggle between pause and resume the scenario
 * @param {boolean} [isPaused] Optional. If supplied, pauses or resumes the scenario
 * @fires pause
 */
sp.container.Manager.prototype.togglePaused = function ( isPaused ) {
	if ( this.isPaused() !== isPaused ) {
		this.scenario.togglePaused( isPaused );
	}
};

<span id='sp-container-Manager-method-isPaused'>/**
</span> * Check whether the scenario is paused
 */
sp.container.Manager.prototype.isPaused = function () {
	return this.scenario.isPaused();
};

<span id='sp-container-Manager-method-setZoom'>/**
</span> * Set scenario zoom
 * @param {number} zoom Zoom factor
 * @fires zoom
 */
sp.container.Manager.prototype.setZoom = function ( zoom ) {
	if ( this.scenario.getZoom() !== zoom ) {
		this.scenario.setZoom( zoom );
	}
};

sp.container.Manager.prototype.setPitchAngle = function ( pitch ) {
	if ( this.scenario ) {
		this.scenario.setPitchAngle( pitch );
	}
};

<span id='sp-container-Manager-method-execute'>/**
</span> * Execute an action or command.
 *
 * @method
 * @param {string} action Symbolic name of action
 * @param {string} [method] Action method name
 * @returns {boolean} Action or command was executed
 */
sp.container.Manager.prototype.execute = function ( action, method ) {
	var trigger, obj, ret;

	if ( !this.enabled ) {
		return;
	}

	// Validate method
	if ( sp.ui.actionFactory.doesActionSupportMethod( action, method ) ) {
		// Create an action object and execute the method on it
		obj = sp.ui.actionFactory.create( action, this );
		ret = obj[method].apply( obj, Array.prototype.slice.call( arguments, 2 ) );
		return ret === undefined || !!ret;
	}
	return false;
};

<span id='sp-container-Manager-method-addCommands'>/**
</span> * Add all commands from initialization options.
 *
 * Commands and triggers must be registered under the same name prior to adding them to the surface.
 *
 * @method
 * @param {string[]} names List of symbolic names of commands in the command registry
 * @throws {Error} If command has not been registered
 * @throws {Error} If trigger has not been registered
 * @throws {Error} If trigger is not complete
 * @fires addCommand
 */
sp.container.Manager.prototype.addCommands = function ( names ) {
	var i, j, len, key, command, triggers, trigger;

	for ( i = 0, len = names.length; i &lt; len; i++ ) {
		command = sp.ui.commandRegistry.lookup( names[i] );
		if ( !command ) {
			throw new Error( &#39;No command registered by that name: &#39; + names[i] );
		}

/*		// Normalize trigger key
		triggers = ve.ui.triggerRegistry.lookup( names[i] );
		if ( !triggers ) {
			throw new Error( &#39;No triggers registered by that name: &#39; + names[i] );
		}
		for ( j = triggers.length - 1; j &gt;= 0; j-- ) {
			trigger = triggers[j];
			key = trigger.toString();
			// Validate trigger
			if ( key.length === 0 ) {
				throw new Error( &#39;Incomplete trigger: &#39; + trigger );
			}
			this.commands[key] = command;
		}*/
/*		this.triggers[names[i]] = triggers;*/
		this.emit( &#39;addCommand&#39;, names[i], command, triggers );
	}
};

<span id='sp-container-Screen'>/**
</span> * Solar Playground screen controller for canvas and context elements
 *
 * @class sp.container.Screen
 * @mixins OO.EventEmitter
 *
 * @param {Object} [config] Configuration object
 */
sp.container.Screen = function SpContainerScreen( config ) {
	this.config = config || {};

	// Mixin constructors
	OO.EventEmitter.call( this );

	this.canvasCenterPoint = { x: 0, y: 0 };

	// Initialize
	this.$canvas = $( &#39;&lt;canvas&gt;&#39; )
		.addClass( &#39;sp-container-canvas&#39; )
		.attr( &#39;width&#39;, this.config.width )
		.attr( &#39;height&#39;, this.config.height );

	this.context = this.$canvas[0].getContext( &#39;2d&#39; );

	// Events
	this.$canvas.on( &#39;mousedown&#39;, $.proxy( this.onCanvasMouseDown, this ) );
	this.$canvas.on( &#39;mousemove&#39;, $.proxy( this.onCanvasMouseMove, this ) );
	this.$canvas.on( &#39;mouseup&#39;, $.proxy( this.onCanvasMouseUp, this ) );
	this.$canvas.on( &#39;mouseout&#39;, $.proxy( this.onCanvasMouseUp, this ) );
};

/* Inheritance */

OO.mixinClass( sp.container.Screen, OO.EventEmitter );

/* Events */

<span id='sp-container-Screen-event-drag'>/**
</span> * @event drag
 * @param {string} action Drag action &#39;start&#39;, &#39;during&#39; or &#39;end&#39;
 * @param {Object|null} coords Mouse x/y coordinates.
 *  * For &#39;start&#39; action, coords are mouseStartingPoint
 *  * For &#39;during&#39; action, coords are the relative distance between
 *    the current mouse coordinates and the initial dragging point.
 *    (In other words, it is the distance &#39;dragged&#39; by the mouse)
 *  * For &#39;end&#39; action, coords are not supplied.
 * point, depending on the action.
 * Dragging the mouse on the screen (moving while mousedown)
 */

<span id='sp-container-Screen-method-onCanvasMouseDown'>/**
</span> * Propogate canvas mousedown event
 * @param {Event} e Event
 * @fires startDrag
 */
sp.container.Screen.prototype.onCanvasMouseDown = function ( e ) {
	this.canvasMouseMoving = true;
	this.mouseStartingPoint = {
		&#39;x&#39;: e.pageX,
		&#39;y&#39;: e.pageY
	};
	this.emit( &#39;drag&#39;, &#39;start&#39;, this.mouseStartingPoint );
};

<span id='sp-container-Screen-method-onCanvasMouseMove'>/**
</span> * Respond to canvas mouse move
 * @param {Event} e Event
 * @fires drag
 */
sp.container.Screen.prototype.onCanvasMouseMove = function ( e ) {
	var coords;
	if ( this.canvasMouseMoving &amp;&amp; !$.isEmptyObject( this.mouseStartingPoint ) ) {
		dx = e.pageX - this.mouseStartingPoint.x;
		dy = e.pageY - this.mouseStartingPoint.y;

		coords = {
			&#39;x&#39;: dx + this.canvasCenterPoint.x,
			&#39;y&#39;: dy + this.canvasCenterPoint.y
		};
		this.emit( &#39;drag&#39;, &#39;during&#39;, coords );
	}
};

<span id='sp-container-Screen-method-onCanvasMouseUp'>/**
</span> * Propogate canvas mouseup event
 * @param {Event} e Event
 * @fires drag
 */
sp.container.Screen.prototype.onCanvasMouseUp = function ( e ) {
	this.canvasMouseMoving = false;
	this.mouseStartingPoint = {};
	this.canvasCenterPoint = {};
	this.emit( &#39;drag&#39;, &#39;end&#39; );
};

<span id='sp-container-Screen-method-drawCircle'>/**
</span> * Draw a circle on the canvas
 * @param {Object} coords Canvas coordinates
 * @param {number} [radius] Circle radius
 * @param {string} [color] Circle color
 * @param {boolean} [hasShadow] Add a shadow
 */
sp.container.Screen.prototype.drawCircle = function ( coords, radius, color, hasShadow ) {
	this.context.save();
	this.context.beginPath();
	this.context.arc(
		coords.x,
		coords.y,
		radius || 5, 0, 2 * Math.PI,
		false
	);
	this.context.fillStyle = color || &#39;white&#39;;
	if ( hasShadow ) {
		this.context.shadowColor = color || &#39;white&#39;;
		this.context.shadowBlur = 20;
		this.context.shadowOffsetX = 0;
		this.context.shadowOffsetY = 0;
	}
	this.context.fill();
	this.context.restore();
};

<span id='sp-container-Screen-method-drawLine'>/**
</span> * Draw a line on the canvas
 * @param {number[]} coords_start Canvas coordinates to start of line
 * @param {number[]} coords_end Canvas coordinates to end of line
 * @param {string} [color] Line color
 * @param {string} [width] Line width
 * @param {boolean} [isDashed] Make the line dashed
 */
sp.container.Screen.prototype.drawLine = function ( coords_start, coords_end, color, width, isDashed ) {
	this.context.beginPath();
	this.context.moveTo( coords_start[0], coords_start[1] );
	this.context.lineTo( coords_end[0], coords_end[1] );
	if ( isDashed &amp;&amp; this.context.setLineDash ) {
		this.context.setLineDash( [ 5, 7 ] );
	}
	this.context.lineWidth = width || 1;
	this.context.strokeStyle = color || &#39;#ffffff&#39;;
	this.context.stroke();
};

<span id='sp-container-Screen-method-clear'>/**
</span> * Clear an area on the canvas
 * @param {number} [square] Dimensions and coordinates of the square
 * to clear. If not set, the entire canvas will be cleared.
 * @param {number} [square.top] Top coordinate of the square
 * @param {number} [square.left] Left coordinate of the square
 * @param {number} [square.width] Width of the square
 * @param {number} [square.height] Height of the square
 */
sp.container.Screen.prototype.clear = function ( square ) {
	var canvasDimensions = this.getDimensions();
	square = square || {};

	// Fix optional values:
	square.left = square.left || 0;
	square.top = square.top || 0;
	square.width = square.width || canvasDimensions.width;
	square.height = square.height || canvasDimensions.height;

	// Erase the square
	this.context.clearRect( square.left, square.top, square.width, square.height );
};

<span id='sp-container-Screen-method-setCenterPoint'>/**
</span> * Set the center point of the center of the scenario.
 * @param {Object} coords Center of scenario coordinates
 */
sp.container.Screen.prototype.setCenterPoint = function ( coords ) {
	this.canvasCenterPoint = {
		&#39;x&#39;: coords.x,
		&#39;y&#39;: coords.y
	};
};

<span id='sp-container-Screen-method-getCenterPoint'>/**
</span> * Get the canvas center point
 * @returns {Object} Center point
 */
sp.container.Screen.prototype.getCenterPoint = function () {
	return this.canvasCenterPoint;
};

<span id='sp-container-Screen-method-getContext'>/**
</span> * Get the canvas context
 * @returns {Object} Canvas context
 */
sp.container.Screen.prototype.getContext = function () {
	return this.$canvas[0].getContext( &#39;2d&#39; );
};

<span id='sp-container-Screen-method-getDimensions'>/**
</span> * Get the canvas dimensions
 * @returns {Object} Width and height of the canvas
 */
sp.container.Screen.prototype.getDimensions = function () {
	return {
		&#39;width&#39;: this.$canvas.width(),
		&#39;height&#39;: this.$canvas.height()
	}
};

<span id='sp-data-CelestialBody'>/**
</span> * Celestial object, defines a moving object in space.
 *
 * @class sp.data.CelestialBody
 * @mixins OO.EventEmitter
 *
 * @param {Object} config Celestial object definition
 */
sp.data.CelestialBody = function SpDataScenarioCelestialObject( config ) {
	config = config || {};

	// Mixin constructors
	OO.EventEmitter.call( this );

	// Cache
	this.cache = {};

	// Cache trail points
	this.trails = [];
	this.frameCounter = 0;
	// TODO: Consider adding these to the global scenario config
	// Keep record of trail every X frames
	this.trailsFrameGap = 2;
	// How many trail points to store
	this.numTrailPoints = 80;

	// Attributes
	this.name = config.name || &#39;&#39;;
	this.description = config.description || &#39;&#39;;
	this.view = config.graphic || {};

	this.transform = { x: 0, y: 0, angle: 0, scale: 1 };

	this.vars = config.vars;

	this.initial_position = config.initial_position || { &#39;x&#39;: 0, &#39;y&#39;: 0 };

	// Link to the object it is orbiting
	this.orbiting = null;

	this.type = config.type || &#39;planet&#39;;

	// Initial radius
	this.radius = Number( config.vars.r ) || 10;
};

/* Inheritance */
OO.mixinClass( sp.data.CelestialBody, OO.EventEmitter );

<span id='sp-data-CelestialBody-method-getSpaceCoordinates'>/**
</span> * Get space coordinates per time.
 * @param {number} time Time unit
 */
sp.data.CelestialBody.prototype.getSpaceCoordinates = function ( time ) {
	var dest, M, G, period, centerOfOrbitCoords;

	time = time || 0;

	if ( this.orbiting ) {
		// Find period if it doesn&#39;t exist
		if ( !this.vars.p ) {
			// Calculate period
			a = this.vars.a[0];// * sp.Scenario.Calculator.constants.AU;
			G = sp.calc.Calculator.constants.G;
			M = this.orbiting.getMass();
			this.vars.p = 2 * Math.PI * Math.sqrt( Math.pow( a, 3) / ( G * M ) );
		}

		// TODO: Cache coordinates
		// TODO: Allow for calculation based on period
		if ( this.vars.a &amp;&amp; this.vars.e &amp;&amp; this.vars.I &amp;&amp; this.vars.L &amp;&amp; this.vars.long_peri &amp;&amp; this.vars.long_node ) {
			this.coordinates = sp.calc.Calculator.solveKepler(
				this.vars,
				time
			);
		} else if ( this.vars.p &amp;&amp; this.vars.r ) {
			// Calculate based on Period
			this.coordinates = { x: 0, y: 0, z: 0 };
			return this.coordinates;
		} else {
			// Not enough details.
			this.coordinates = { x: 0, y: 0, z: 0 };
			return this.coordinates;
		}

		// TODO: Calculate the position relative to the orbit mass to allow for
		// sub systems like moons

		// Adjust the coordinates from center of orbit to world coordinates
		centerOfOrbitCoords = this.orbiting.getSpaceCoordinates( time );
		if ( centerOfOrbitCoords ) {
			this.coordinates = {
				&#39;x&#39;: this.coordinates.x + centerOfOrbitCoords.x,
				&#39;y&#39;: this.coordinates.y + centerOfOrbitCoords.y,
				&#39;z&#39;: this.coordinates.z + centerOfOrbitCoords.z
			};
		}
	} else {
		this.coordinates = { x: 0, y: 0, z: 0 };
	}
	return this.coordinates;
};

<span id='sp-data-CelestialBody-method-storeTrailPoint'>/**
</span> * Store the coordinate in the trail queue. Stores the space coordinates.
 * Dequeue the first when trail number cap is reached.
 * @param {Object} coordinates Coordinates of the trails
 */
sp.data.CelestialBody.prototype.storeTrailPoint = function ( coordinates ) {
	// Store coordinates for trails
	this.trails.push( coordinates );
	if ( this.trails.length &gt; this.numTrailPoints ) {
		// Dequeue the first
		this.trails.shift();
	}
};

<span id='sp-data-CelestialBody-method-getTrailPoints'>/**
</span> * Get the trail points.
 * @returns {Object[]} Space coordinates for the trails
 */
sp.data.CelestialBody.prototype.getTrailPoints = function () {
	return this.trails;
};

<span id='sp-data-CelestialBody-method-flushTrailPoints'>/**
</span> * Flush the trails queue completely.
 */
sp.data.CelestialBody.prototype.flushTrailPoints = function () {
	this.trails = [];
	this.frameCounter = 0;
};

<span id='sp-data-CelestialBody-method-getType'>/**
</span> * Get object type
 * @returns {string} Celestial object type, &#39;star&#39; or &#39;planet&#39;
 */
sp.data.CelestialBody.prototype.getType = function () {
	return this.type;
};

<span id='sp-data-CelestialBody-method-getName'>/**
</span> * Get object name
 * @returns {string} Celestial object name
 */
sp.data.CelestialBody.prototype.getName = function () {
	return this.name;
};

<span id='sp-data-CelestialBody-method-getDescription'>/**
</span> * Get object description
 * @returns {string} Celestial object description
 */
sp.data.CelestialBody.prototype.getDescription = function () {
	return this.description;
};

<span id='sp-data-CelestialBody-method-setOrbit'>/**
</span> * Set the object this object is orbiting
 * @param {sp.data.CelestialBody} obj Object that is the center of the orbit
 */
sp.data.CelestialBody.prototype.setOrbit = function ( obj ) {
	this.orbiting = obj;
};

<span id='sp-data-CelestialBody-method-getOrbit'>/**
</span> * Retrieve the object that is the center of orbit
 * @returns {sp.data.CelestialBody} obj Object that is the center of the orbit
 */
sp.data.CelestialBody.prototype.getOrbit = function () {
	return this.orbiting;
};

<span id='sp-data-CelestialBody-method-setName'>/**
</span> * Set object name
 * @param {string} name New object name
 */
sp.data.CelestialBody.prototype.setName = function ( name ) {
	this.name = name;
};

<span id='sp-data-CelestialBody-method-setDescription'>/**
</span> * Set object description
 * @param {string} desc New object description
 */
sp.data.CelestialBody.prototype.setDescription = function ( desc ) {
	this.description = desc;
};

sp.data.CelestialBody.prototype.getMass = function () {
	return this.vars.m;
};

sp.data.CelestialBody.prototype.getView = function () {
	return this.view;
}

<span id='sp-data-CelestialBody-method-'>/**
</span> * Get the planet radius if it exists.
 * @returns {number|null} Planet radius in km
 */
sp.data.CelestialBody.prototype.getRadius = function () {
	return this.vars.r;
};

<span id='sp-data-Scenario'>/**
</span> * Solar playground scenario
 *
 * @class sp.data.Scenario
 * @mixins OO.EventEmitter
 *
 * @param {sp.container.Screen} screen Target screen for the scenario
 * @param {Object} scenario Scenario configuration object
 * @param {Object} [config] Configuration options. Will override any
 * configuration in the scenario object
 */
sp.data.Scenario = function SpDataScenario( screen, scenario, config ) {
	var objects, canvasDimensions,
		toRadians = Math.PI / 180;

	// Mixin constructors
	OO.EventEmitter.call( this );

	config = config || {};

	// TODO: Validate the scenario object to make sure all required
	// elements exist.

	this.screen = screen;

	this.paused = true;
	this.objects = {};

	// Prepare general configuration
	this.config = $.extend( {}, scenario.config, config );

	// view controller
	canvasDimensions = this.screen.getDimensions();
	this.viewConverter = new sp.view.Converter( {
		&#39;zoom&#39;: this.config.init_zoom || 1,
		&#39;canvasDimensions&#39;: canvasDimensions,
		&#39;yaw&#39;: this.config.init_yaw * toRadians || 0,
		&#39;pitch&#39;: this.config.init_pitch * toRadians || 0,
		&#39;scale&#39;: {
			&#39;orbit&#39;: this.config.orbit_scale || 0.5 * Math.pow( 10, -5 ),
			&#39;planets&#39;: this.config.planet_scale
		}
	} );

	this.grid = new sp.view.Grid( this.screen, this.viewConverter );

	this.showTrails = this.config.show_trails || false;
	this.showGrid = this.config.show_grid || false;
	this.frameCounter = 0;
	this.trailsFrameGap = 5;

	this.pov_key = this.config.init_pov;
	this.pov_object = null;

	this.date = this.config.start_time || { day: 1, month: 1, year: 2000 };
	this.time = 0;
	this.speed = this.config.init_speed || 1;

	// Prepare the objects
	this.processObjects( scenario.objects || {} );

	// Events
	this.screen.connect( this, { &#39;drag&#39;: &#39;onScreenDrag&#39; } );
	this.viewConverter.connect( this, { &#39;pitch&#39;: &#39;onPitchChange&#39; } );
};

/* Inheritance */
OO.mixinClass( sp.data.Scenario, OO.EventEmitter );

/* Events */

<span id='sp-data-Scenario-event-paused'>/**
</span> * @event paused
 * @param {boolean} [isPaused] Paused or resumed
 * Change in pause/resume state
 */

<span id='sp-data-Scenario-event-pov'>/**
</span> * @event pov
 * @param {string} pov_key The key of the new POV object
 * Change in point-of-view (POV) for the scenario
 */

<span id='sp-data-Scenario-event-zoom'>/**
</span> * @event zoom
 * @param {number} zoom Current zoom factor
 * Change the zoom level for the scenario
 */

<span id='sp-data-Scenario-event-pitch'>/**
</span> * @event pitch
 * @param {number} pitch Current pitch angle
 * Change the pitch angle for display
 */

/* Methods */

<span id='sp-data-Scenario-method-onScreenDrag'>/**
</span> * Respond to screen drag
 * @param {string} action Action parameter for &#39;start&#39;, &#39;during&#39;, and &#39;end&#39;
 * @param {Object} [coords] Coordinates
 */
sp.data.Scenario.prototype.onScreenDrag = function ( action, coords ) {
	if ( action === &#39;start&#39; ) {
		this.screen.setCenterPoint( this.getCenterPoint() );
	} else if ( action === &#39;during&#39; ) {
		this.setCenterPoint( { &#39;x&#39;: coords.x, &#39;y&#39;: coords.y } );
		this.flushAllTrails();
		this.screen.clear();
		this.draw();
	} else if ( action === &#39;end&#39; ) {
		this.screen.setCenterPoint( this.getCenterPoint() );
	}
};

<span id='sp-data-Scenario-method-onPitchChange'>/**
</span> * Propogate the pitch event from the view controller
 * @param {number} pitch Current pitch angle
 * @fires pitch
 */
sp.data.Scenario.prototype.onPitchChange = function ( pitch ) {
	this.emit( &#39;pitch&#39;, pitch );
};

<span id='sp-data-Scenario-method-processObjects'>/**
</span> * Process the solar playground simulator objects
 * @param {Object} scenarioObjects Simulation objects definition
 */
sp.data.Scenario.prototype.processObjects = function ( scenarioObjects ) {
	var o, co, radii_diff, step_size, radius, circle_radius, smallest_radii,
		radii = {
			&#39;star&#39;: [],
			&#39;planet&#39;: []
		};

	// Initialize celestial objects
	for ( o in scenarioObjects ) {
		this.objects[o] = new sp.data.CelestialBody( scenarioObjects[o] );

		// Collect all radii
		if ( scenarioObjects[o].vars.r ) {
			if ( scenarioObjects[o].type === &#39;star&#39; ) {
				radii.star.push( Number( scenarioObjects[o].vars.r ) );
			} else {
				radii.planet.push( Number( scenarioObjects[o].vars.r ) );
			}
		}
	}

	// Send the radii list to the view
	this.viewConverter.setRadiiList( radii );

	// Figure out which objects orbit what
	for ( co in this.objects ) {
		if ( scenarioObjects[co] &amp;&amp; this.objects[scenarioObjects[co].orbiting] ) {
			// Connect the object to its center of orbit
			this.objects[co].setOrbit( this.objects[scenarioObjects[co].orbiting] );
		}
	}

	// Set initial POV
	if ( this.pov_key &amp;&amp; this.objects[this.pov_key] ) {
		this.pov_object = this.objects[this.pov_key];
		this.viewConverter.setPOV( this.objects[this.pov_key].getSpaceCoordinates( 0 ) );
	}
};

<span id='sp-data-Scenario-method-setPOV'>/**
</span> * Set the POV object
 * @param {string} povKey Object key for the pov
 * @fires pov
 */
sp.data.Scenario.prototype.setPOV = function ( povKey ) {
	if ( povKey &amp;&amp; this.objects[povKey] &amp;&amp; this.pov_key !== povKey ) {
		this.pov_key = povKey;

		this.pov_object = this.objects[this.pov_key];
		this.viewConverter.setPOV( this.objects[this.pov_key].getSpaceCoordinates( 0 ) );
		this.screen.clear();
		this.flushAllTrails();
		this.draw();

		this.emit( &#39;pov&#39;, this.pov_key );
	}
};

<span id='sp-data-Scenario-method-getPOV'>/**
</span> * Get the POV key currently set
 * @returns {string} POV key
 */
sp.data.Scenario.prototype.getPOV = function () {
	return this.pov_key;
};

<span id='sp-data-Scenario-method-draw'>/**
</span> * Draw all elements
 * @param {number} time Time
 * @param {boolean} ignoreTrails Ignore trails despite settings
 */
sp.data.Scenario.prototype.draw = function ( time, ignoreTrails ) {
	var o, coords, canvasCoords, graphic, radius, trails;

	time = time || this.time;

	if ( this.showGrid ) {
		this.grid.draw();
	}

	for ( o in this.objects ) {
		coords = this.objects[o].getSpaceCoordinates( time );

		// TODO: Allow POV that isn&#39;t an object
		// Update POV coordinates
		if ( o === this.pov_key ) {
			this.viewConverter.setPOV( coords );
		}
		// Get graphic details
		graphic = this.objects[o].getView();

		// Translate coordinates to canvas
		canvasCoords = this.viewConverter.getCoordinates( coords );
		if ( canvasCoords ) {
			// TODO: Allow the user to choose between relative radii and preset radius value
			// in the view parameters, instead of having the view take precedence randomly
			radius = this.viewConverter.getRadius( this.objects[o].getRadius(), this.objects[o].getType() );

			// Draw the object
			this.screen.drawCircle(
				canvasCoords,
				radius,
				graphic.color,
				// Add a shadow to stars
				this.objects[o].getType() === &#39;star&#39;
			);
		}

		// Draw trails
		if ( !ignoreTrails &amp;&amp; this.showTrails &amp;&amp; o !== this.pov_key ) {
			// Store trails
			// If &#39;canvasCoords&#39; is null, still store to continue
			// with the movement
			this.frameCounter++;
			if ( this.frameCounter &gt;= this.trailsFrameGap ) {
				this.objects[o].storeTrailPoint( canvasCoords );
				this.frameCounter = 0;
			}

			// Get the trail points
			trails = this.objects[o].getTrailPoints();
			for ( i = 0; i &lt; trails.length; i++ ) {
				// But only draw if we have the trails
				if ( trails[i] ) {
					// Draw all trails as dots
					this.screen.drawCircle(
						trails[i],
						1,
						// TODO: Consider making trail colors a configuration option
						graphic.color || &#39;#FF005D&#39; // Bright pink
					);
				}
			}
		}
	}
};

<span id='sp-data-Scenario-method-flushAllTrails'>/**
</span> * Flush all trails from all objects
 */
sp.data.Scenario.prototype.flushAllTrails = function () {
	var o;
	for ( o in this.objects ) {
		this.objects[o].flushTrailPoints();
	}
};

<span id='sp-data-Scenario-method-run'>/**
</span> * Run the scenario
 */
sp.data.Scenario.prototype.run = function () {
	if ( !this.paused ) {
		// Clear canvas
		this.screen.clear();

		// Draw canvas
		this.draw( this.time );

		// Increase time
		this.time += 0.0000000001 * this.speed;

		window.requestNextAnimationFrame( $.proxy( this.run, this ) );
	}
};

<span id='sp-data-Scenario-method-getAllObjects'>/**
</span> * Retrieve all the celestial objects attached to this scenario
 * @returns {sp.data.Scenario.CelestialObject} All objects in the scenario
 */
sp.data.Scenario.prototype.getAllObjects = function () {
	return this.objects;
};

<span id='sp-data-Scenario-method-togglePaused'>/**
</span> * Toggle between pause and resume the scenario
 * @param {boolean} [isPause] Optional. If supplied, pauses or resumes the scenario
 * @fires paused
 */
sp.data.Scenario.prototype.togglePaused = function ( isPause ) {
	if ( isPause === undefined ) {
		isPause = !this.paused;
	}
	isPause = !!isPause;

	this.paused = isPause;
	this.run();

	this.emit( &#39;pause&#39;, this.paused );
};

<span id='sp-data-Scenario-method-isPaused'>/**
</span> * Check whether the scenario is paused
 */
sp.data.Scenario.prototype.isPaused = function () {
	return this.paused;
};

<span id='sp-data-Scenario-method-pause'>/**
</span> * Pause the scenario
 */
sp.data.Scenario.prototype.pause = function () {
	this.togglePaused( true );
};

<span id='sp-data-Scenario-method-resume'>/**
</span> * Resume the scenario
 */
sp.data.Scenario.prototype.resume = function () {
	this.togglePaused( false );
	this.run();
};

<span id='sp-data-Scenario-method-toggleGrid'>/**
</span> * Toggle the grid display
 * @param {Boolean} isShowGrid Show grid
 * @fires grid
 */
sp.data.Scenario.prototype.toggleGrid = function ( isShowGrid ) {
	if ( isShowGrid === undefined ) {
		isShowGrid = !this.showGrid;
	}
	isShowGrid = !!isShowGrid;

	this.showGrid = isShowGrid;
	// Clear canvas
	this.screen.clear();

	// Draw canvas
	this.draw( this.time );

	this.emit( &#39;grid&#39;, this.showGrid );
};

<span id='sp-data-Scenario-method-isShowGrid'>/**
</span> * Check whether the scenario is paused
 */
sp.data.Scenario.prototype.isShowGrid = function () {
	return this.showGrid;
};

<span id='sp-data-Scenario-method-setZoom'>/**
</span> * Increase or decrease scenario zoom levels
 * @param {number} z Zoom level, negative for zoom out
 */
sp.data.Scenario.prototype.setZoom = function ( z ) {
	this.viewConverter.setZoom( z );
	this.flushAllTrails();
	if ( this.isPaused() ) {
		this.screen.clear();
		this.draw( this.time, true );
	}
	this.emit( &#39;zoom&#39;, z );
};

<span id='sp-data-Scenario-method-getZoom'>/**
</span> * Retrieve the zoom level
 * @returns {numver} Current zoom level
 */
sp.data.Scenario.prototype.getZoom = function () {
	return this.viewConverter.getZoom();
};

<span id='sp-data-Scenario-method-setCenterPoint'>/**
</span> * Set the viewpoint&#39;s center point
 * @param {Object} coords x/y coordinates of the center of the system
 */
sp.data.Scenario.prototype.setCenterPoint = function ( coords ) {
	this.viewConverter.setCenterPoint( coords );
	this.flushAllTrails();
	if ( this.isPaused() ) {
		this.screen.clear();
		this.draw( this.time, true );
	}
};

<span id='sp-data-Scenario-method-getCenterPoint'>/**
</span> * Get the current center point of the view
 * @returns {Object} x/y coordinates of the current center point
 */
sp.data.Scenario.prototype.getCenterPoint = function () {
	return this.viewConverter.getCenterPoint();
};

<span id='sp-data-Scenario-method-addToCenterPoint'>/**
</span> * Add to the center point
 * @param {number} [x] Amount to add to X coordinate
 * @param {number} [y] Amount to add to Y coordinate
 */
sp.data.Scenario.prototype.addToCenterPoint = function ( x, y ) {
	this.viewConverter.addToCenterPoint( x, y );
};

<span id='sp-data-Scenario-method-setPitchAngle'>/**
</span> * Set the pitch angle for the scenario
 * @param {[type]} pitch [description]
 */
sp.data.Scenario.prototype.setPitchAngle = function ( pitch ) {
	this.viewConverter.setPitchAngle( pitch );
	this.flushAllTrails();
	if ( this.isPaused() ) {
		this.screen.clear();
		this.draw( this.time, true );
	}
};

<span id='sp-data-Scenario-method-getPitchAngle'>/**
</span> * Get the current pitch angle
 * @returns {number} Pitch angle
 */
sp.data.Scenario.prototype.getPitchAngle = function () {
	return this.viewConverter.getPitchAngle();
};

<span id='sp-view-Converter'>/**
</span> * Solar Playground view converter.
 * Converts between space coordinates and screen coordinates and controls the visual presentation.
 *
 * @class sp.view.Converter
 * @mixins OO.EventEmitter
 *
 * @param {Object} [config] Configuration object
 */
sp.view.Converter = function SpViewConverter( config ) {
	// Mixin constructors
	OO.EventEmitter.call( this );

	// Configuration
	this.config = config || {};

	this.zoom = this.config.zoom || 1;
	this.orbit_scale = this.config.orbit_scale || 1;
	this.yaw = this.config.yaw;
	this.pitch = this.config.pitch;

	this.canvasDimensions = this.config.canvasDimensions || { &#39;width&#39;: 0, &#39;height&#39;: 0 };
	this.scenarioCenterPoint = {
		&#39;x&#39;: this.canvasDimensions.width / 2,
		&#39;y&#39;: this.canvasDimensions.height / 2
	};

	this.pov = { &#39;x&#39;: 0, &#39;y&#39;: 0, &#39;z&#39;: 0 };
	this.radii_list = null;

	// Set up visible canvas-scaled radius steps in pixels
	this.radii = {
		&#39;star&#39;: [ 25, 30, 32, 35 ],
		&#39;planet&#39;: [ 10, 12, 14, 16 ],
		&#39;moon&#39;: [ 4, 8, 10, 12 ]
	};
	// Define the step between each value
	this.radius_step = {
		&#39;star&#39;: 0,
		&#39;planet&#39;: 0
	};
};

/* Inheritance */
OO.mixinClass( sp.view.Converter, OO.EventEmitter );

/* Events */

<span id='sp-view-Converter-event-changePOV'>/**
</span> * Change of the POV coordinates in space
 * @event changePOV
 * @param {Object} New space coordinates of the POV
 */

/* Methods */

<span id='sp-view-Converter-method-setPOV'>/**
</span> * Set the coordinates of the current POV object
 * @param {Object} pov_coords The 3d coordinates of the current POV
 * @fires changePOV
 */
sp.view.Converter.prototype.setPOV = function ( pov_coords ) {
	if ( !pov_coords ) {
		return;
	}
	if ( pov_coords.x !== this.pov.x || pov_coords.y !== this.pov.y ) {
		this.pov = pov_coords;
		this.emit( &#39;changePOV&#39;, pov_coords );
	}
};

<span id='sp-view-Converter-method-getCoordinates'>/**
</span> * Translate between space coordinates and viewpoint coordinates
 * on the canvas.
 * @param {Object} spaceCoords Original 3D space coordinates
 * @returns {Object} Canvas 2d coordinates
 */
sp.view.Converter.prototype.getCoordinates = function ( spaceCoords ) {
	var ca = Math.cos( this.yaw ),
		sa = Math.sin( this.yaw ),
		cb = Math.cos( this.pitch ),
		sb = Math.sin( this.pitch ),
		dx = this.scenarioCenterPoint.x,
		dy = this.scenarioCenterPoint.y,
		scale = Math.sqrt( this.orbit_scale * this.zoom );

	// TODO: Work out proper scale
	x = ( spaceCoords.x - this.pov.x ) * scale;
	y = ( spaceCoords.y - this.pov.y ) * scale;
	z = ( spaceCoords.z - this.pov.z ) * scale;

	destination = {
		&#39;x&#39;: x * ca - y * sa + dx,
		&#39;y&#39;: x * sa + y * ca
	};
	destination.z = destination.y * sb;
	destination.y = destination.y * cb + dy;

	// Check if destination is inside the canvas. Return null otherwise.
	if (
		destination.x &gt; 0 &amp;&amp;
		destination.x &lt;= this.canvasDimensions.width &amp;&amp;
		destination.y &gt; 0 &amp;&amp;
		destination.y &lt;= this.canvasDimensions.height
	) {
		return destination;
	}
};

<span id='sp-view-Converter-method-setRadiiList'>/**
</span> * Calculate radius size steps from a new radii list
 * @param {Object} rList Actual size radii of all celestial objects
 * divided into &#39;stars&#39; and &#39;planets&#39; to distinguish relative sizes better
 */
sp.view.Converter.prototype.setRadiiList = function ( rList ) {
	var type, diff;

	this.radii_list = rList;

	for ( type in this.radii_list ) {
		// Sort by size, ascending
		this.radii_list[type].sort( function ( a, b ) {
			return a - b;
		} );

		// Figure out steps for each of the types
		diff = this.radii_list[type][this.radii_list[type].length - 1] -
			this.radii_list[type][0];

		this.radius_step[type] = diff / this.radii[type].length
	}
};

<span id='sp-view-Converter-method-getRadius'>/**
</span> * Translate between the original radius and the canvas radius in pixels
 * @param {number} orig_radius Object&#39;s original radius
 * @returns {number} Actual radius in pixels
 */
sp.view.Converter.prototype.getRadius = function ( orig_radius, type ) {
	var radius, index,
		step = this.radius_step[type] || 1;

	type = type || &#39;planet&#39;;
	index = Math.floor( orig_radius / step );

	if ( index &gt; this.radii[type].length - 1 ) {
		index = this.radii[type].length - 1;
	}

	radius = Math.sqrt( this.radii[type][ index ] * this.zoom ) / 100;

	return ( radius &gt;= 2 ) ? radius : 2;
};

<span id='sp-view-Converter-method-setZoom'>/**
</span> * Increase or decrease scenario zoom levels
 * @param {number} z Zoom level, negative for zoom out
 */
sp.view.Converter.prototype.setZoom = function ( z ) {
	this.zoom += z;
};

<span id='sp-view-Converter-method-getZoom'>/**
</span> * Get the current zoom factor
 * @returns {number} zoom Zoom factor
 */
sp.view.Converter.prototype.getZoom = function () {
	return this.zoom;
};

<span id='sp-view-Converter-method-setCenterPoint'>/**
</span> * Set the scenario center point
 * @param {Object} coords x/y coordinates of the center of the system
 */
sp.view.Converter.prototype.setCenterPoint = function ( coords ) {
	coords = coords || {};

	x = coords.x || 0;
	y = coords.y || 0;

	this.scenarioCenterPoint = {
		&#39;x&#39;: x,
		&#39;y&#39;: y
	};
};

<span id='sp-view-Converter-method-getCenterPoint'>/**
</span> * Get the current center point of the view
 * @returns {Object} x/y coordinates of the current center point
 */
sp.view.Converter.prototype.getCenterPoint = function () {
	return this.scenarioCenterPoint;
};

<span id='sp-view-Converter-method-addToCenterPoint'>/**
</span> * Add to the center point
 * @param {number} [x] Amount to add to X coordinate
 * @param {number} [y] Amount to add to Y coordinate
 */
sp.view.Converter.prototype.addToCenterPoint = function ( x, y ) {
	x = x || 0;
	y = y || 0;

	this.scenarioCenterPoint.x += x;
	this.scenarioCenterPoint.y += y;
};

<span id='sp-view-Converter-method-setPitchAngle'>/**
</span> * Set the pitch angle for the view
 */
sp.view.Converter.prototype.setPitchAngle = function ( pitch ) {
	if ( this.pitch !== pitch ) {
		this.pitch = pitch;
		this.emit( &#39;pitch&#39;, this.pitch );
	}
};

sp.view.Converter.prototype.getPitchAngle = function () {
	return this.pitch;
};

<span id='sp-view-Grid'>/**
</span> * Solar Playground view grid.
 * Display a grid on the canvas
 *
 * @class
 * @param {sp.container.Screen} screen Screen handler
 * @param {sp.view.Converter} view View handler
 * @param {Object} [config] Configuration object
 */
sp.view.Grid = function SpViewGrid( screen, view, config ) {
	this.screen = screen;
	this.viewConverter = view;

	// Configuration
	this.config = config || {};

	this.color = this.config.grid_color || &#39;#575757&#39;;
	this.spacing = this.config.spacing || { x: 45, y: 45 };
};

<span id='sp-view-Grid-method-draw'>/**
</span> * Draw the grid on the canvas, based on the scenario centerpoint
 * and the pitch.
 */
sp.view.Grid.prototype.draw = function SpViewDraw() {
	var dx, margin, topPt, botPt,
		toRadians = Math.PI / 180,
		counter = 0,
		dimensions = this.screen.getDimensions(),
		context = this.screen.getContext(),
		center = this.viewConverter.getCenterPoint(),
		pitch = this.viewConverter.getPitchAngle();
	// TODO: Add support for yaw

	// TODO: Draw an elliptical grid based on the orbits

	// Calculate margin
	if ( pitch &gt; Math.PI / 4 ) {
		margin = ( dimensions.height / 2 ) * Math.tan( pitch );
	} else if ( pitch &gt; 0 &amp;&amp; pitch &lt; Math.PI / 4 ) {
		margin = ( dimensions.height / 2 ) * Math.tan( Math.PI / 4 - pitch );
	} else {
		margin = 0;
	}
	H = dimensions.height / 2 - margin;
	d = H * Math.tan( pitch );

	topEdge = center.y - H;
	bottomEdge = center.y + H;

	// Draw top and bottom margins
	this.screen.drawLine(
		[ 0, topEdge ],
		[ dimensions.width, topEdge ],
		this.color, 1, false
	);
	this.screen.drawLine(
		[ 0, bottomEdge ],
		[ dimensions.width, bottomEdge ],
		this.color, 1, false
	);

	// Draw x origin
	this.screen.drawLine(
		[ 0, center.y ],
		[ dimensions.width, center.y ],
		this.color, 1, false
	);

	// Draw x grid up and down (from center)
	counter = 0;
	gridPoint = center.y;
	while ( gridPoint - this.spacing.x &gt; topEdge ) {
		gridPoint = center.y - this.spacing.x * counter;
		this.screen.drawLine(
			[ 0, gridPoint ],
			[ dimensions.width, gridPoint ],
			this.color, 1, false
		);
		counter++;
	}

	counter = 0;
	gridPoint = center.y;
	while ( gridPoint + this.spacing.x &lt; bottomEdge ) {
		gridPoint = center.y + this.spacing.x * counter;
		this.screen.drawLine(
			[ 0, gridPoint ],
			[ dimensions.width, gridPoint ],
			this.color, 1, false
		);
		counter++;
	}

	// Draw y origin (tilted as necessary)
	originGridPointTop = center.x + d;
	originGridPointBottom = center.x - d;
	this.screen.drawLine(
		[ center.x + d, topEdge ],
		[ center.x - d, bottomEdge ],
		this.color, 1, false
	);

	// Draw y grid left and right (from center)
	gridPointTop = originGridPointTop;
	gridPointBottom = originGridPointBottom;
	while (
		gridPointTop &gt; 0 &amp;&amp; gridPointTop &lt; dimensions.width ||
		gridPointBottom &gt; 0 &amp;&amp; gridPointBottom &lt; dimensions.width
	) {
		gridPointTop += this.spacing.y;
		gridPointBottom += this.spacing.y;
		this.screen.drawLine(
			[ gridPointTop, topEdge ],
			[ gridPointBottom, bottomEdge ],
			this.color, 1, false
		);
	}

	gridPointTop = originGridPointTop;
	gridPointBottom = originGridPointBottom;
	while (
		gridPointTop &gt; 0 &amp;&amp; gridPointTop &lt; dimensions.width ||
		gridPointBottom &gt; 0 &amp;&amp; gridPointBottom &lt; dimensions.width
	) {
		gridPointTop -= this.spacing.y;
		gridPointBottom -= this.spacing.y;
		this.screen.drawLine(
			[ gridPointTop, topEdge ],
			[ gridPointBottom, bottomEdge ],
			this.color, 1, false
		);
	}
};

<span id='sp-view-Grid-method-getCenterPoint'>/**
</span> * Get the current center point of the view
 * @returns {Object} x/y coordinates of the current center point
 */
sp.view.Grid.prototype.getCenterPoint = function () {
	return this.viewConverter.getCenterPoint();
};

<span id='sp-ui-Command-method-constructor'><span id='sp-ui-Command'>/**
</span></span> * Command that executes an action.
 *
 * @class
 *
 * @constructor
 * @param {string} name Symbolic name for the command
 * @param {string} action Action to execute when command is triggered
 * @param {string} method Method to call on action when executing
 */
sp.ui.Command = function SpUiCommand( name, action, method ) {
	this.name = name;
	this.action = action;
	this.method = method;
	this.data = Array.prototype.slice.call( arguments, 3 );
};

/* Methods */

<span id='sp-ui-Command-method-execute'>/**
</span> * Execute command on a surface.
 *
 * @param {ve.ui.Surface} surface Surface to execute command on
 * @returns {Mixed} Result of command execution.
 */
sp.ui.Command.prototype.execute = function ( surface ) {
	return surface.execute.apply( surface, [ this.action, this.method ].concat( this.data ) );
};

<span id='sp-ui-Command-method-getAction'>/**
</span> * Get command action.
 *
 * @returns {string} action Action to execute when command is triggered
 */
sp.ui.Command.prototype.getAction = function () {
	return this.action;
};

<span id='sp-ui-Command-method-getMethod'>/**
</span> * Get command method.
 *
 * @returns {string} method Method to call on action when executing
 */
sp.ui.Command.prototype.getMethod = function () {
	return this.method;
};

<span id='sp-ui-Command-method-getName'>/**
</span> * Get command name.
 *
 * @returns {string} name The symbolic name of the command.
 */
sp.ui.Command.prototype.getName = function () {
	return this.name;
};

<span id='sp-ui-Command-method-getData'>/**
</span> * Get command data.
 *
 * @returns {Array} data Additional data to pass to the action when executing
 */
sp.ui.Command.prototype.getData = function () {
	return this.data;
};

<span id='sp-ui-CommandRegistry-method-constructor'><span id='sp-ui-CommandRegistry'>/**
</span></span> * Command registry.
 *
 * @class sp.ui.CommandRegistry
 * @extends OO.Registry
 * @constructor
 */
sp.ui.CommandRegistry = function SpUiCommandRegistry() {
	// Parent constructor
	OO.Registry.call( this );
};

/* Inheritance */

OO.inheritClass( sp.ui.CommandRegistry, OO.Registry );

/* Methods */

<span id='sp-ui-CommandRegistry-method-register'>/**
</span> * Register a constructor with the factory.
 *
 * @method
 * @param {sp.ui.Command} command Command object
 * @throws {Error} If command is not an instance of sp.ui.Command
 */
sp.ui.CommandRegistry.prototype.register = function ( command ) {
	// Validate arguments
	if ( !( command instanceof sp.ui.Command ) ) {
		throw new Error(
			&#39;command must be an instance of sp.ui.Command, cannot be a &#39; + typeof command
		);
	}

	OO.Registry.prototype.register.call( this, command.getName(), command );
};

/* Initialization */

sp.ui.commandRegistry = new sp.ui.CommandRegistry();

/* Registrations */

sp.ui.commandRegistry.register(
	new sp.ui.Command( &#39;play&#39;, &#39;playTools&#39;, &#39;play&#39; )
);
/*sp.ui.commandRegistry.register(
	new sp.ui.Command( &#39;speed&#39;, &#39;playTools&#39;, &#39;speed&#39; )
);
sp.ui.commandRegistry.register(
	new sp.ui.Command( &#39;zoomin&#39;, &#39;viewTools&#39;, &#39;zoom&#39;, -1000 )
);
sp.ui.commandRegistry.register(
	new sp.ui.Command( &#39;zoomout&#39;, &#39;viewTools&#39;, &#39;zoom&#39;, 1000 )
);
*/

<span id='sp-ui-Loader'>/**
</span> * Gui Loader. Creates the gui to be attached to
 * the SolarPlayground container.
 *
 * @class sp.ui.Loader
 * @mixins OO.EventEmitter
 *
 * @param {Object} config Gui definition
 * @config {string} module The GUI module. Defaults to &#39;ooui&#39;
 * @config {jQuery} jQuery object for the container on top of which
 *  the GUI should be built.
 */
sp.ui.Loader = function SpGuiInitializer( config ) {
	config = config || {};

	// Mixin constructors
	OO.EventEmitter.call( this );

	this.moduleName = config.module || &#39;ooui&#39;;
	this.module = null;

	this.scenario = config.scenario;
	this.settings = config.settings || {};
	this.container = config.container;

	this.$spinner = $( &#39;&lt;div&gt;&#39; )
		.addClass( &#39;sp-system-spinner&#39; )
		.appendTo( this.container.$container );
};

/* Inheritance */
OO.mixinClass( sp.ui.Loader, OO.EventEmitter );

<span id='sp-ui-Loader-method-initialize'>/**
</span> * Create the GUI according to the ui module
 * @returns {sp.ui.ext.ooui.Mod.Play} The play module attached to the container
 */
sp.ui.Loader.prototype.initialize = function () {
	var module;
	this.$spinner.show();
	/// TODO: Use a factory instead of this quick and somewhat
	/// lame &#39;switch&#39; statement, so we can allow for proper
	/// modules for the GUI
	switch ( this.moduleName ) {
		case &#39;jqueryui&#39;:
			this.module = new sp.ui.ext.jqueryui.Mod.Play( this.container, this.settings );
			break;
		case &#39;ooui&#39;:
		default:
			this.module = new sp.ui.ext.ooui.Mod.Play( this.container, this.settings );
			break;
	}

	module = this.module.initialize( this.settings );
	this.$spinner.hide();
	return module;
};

<span id='sp-ui-ext-Play'>/**
</span> * General Gui module. All &#39;Play&#39; GUI modules should extend this.
 *
 * @class sp.ui.ext.Play
 *
 * @param {sp.Container} container The container to attach the GUI to
 * @param {Object} [config] Gui module definition
 */
sp.ui.ext.Play = function SpUiExtPlay ( container, config ) {
	config = config || {};

	// Mixin constructors
	OO.EventEmitter.call( this );

	this.container = container;
};

/* Inheritance */
OO.mixinClass( sp.ui.ext.Play, OO.EventEmitter );

/* Events */

<span id='sp-ui-ext-Play-event-play'>/**
</span> * Play or pause scenario
 * @event play
 * @param {boolean} isPlay Play scenario or pause
 */

<span id='sp-ui-ext-Play-event-zoom'>/**
</span> * Zoom in or out
 * @event zoom
 * @param {number} zoomLevel How much to zoom. Negative to zoom out.
 */

<span id='sp-ui-ext-Play-event-pov'>/**
</span> * Change point of view object
 * @event pov
 * @param {string} povObjName New POV object name or key
 */

/* Methods */

<span id='sp-ui-ext-Play-method-initialize'>/**
</span> * Initialize the Gui
 * @returns {sp.ui.ext.Play}
 */
sp.ui.ext.Play.prototype.initialize = function () {
	// Set up global GUI features

	// Full screen button
	this.$fullscreen = $( &#39;&lt;div&gt;&#39; )
		.addClass( &#39;sp-ui-fullscreen-button&#39; );

	this.container.$container.append( this.$fullscreen );
	return this;
};

<span id='sp-ui-ext-Play-method-addToPOVList'>/**
</span> * Add a tool to the POV list
 * @abstract
 * @param {string} name Tool name
 * @param {string} title Title or alternate text
 * @param {string} [icon] Tool icon
 * @throws {Error} If the method is not implemented in the child class
 */
sp.ui.ext.Play.prototype.addToPOVList = function ( name, title, icon ) {
	throw new Error( &#39;sp.Gui.Module.addToPOVList must be implemented in child class.&#39; );
};

<span id='sp-ui-ext-Play'>/**
</span> * Status bar module
 *
 * @class sp.ui.ext.Play
 * @abstract
 *
 * @param {sp.Container} container The container to attach the GUI to
 * @param {Object} [config] Gui module definition
 */
sp.ui.ext.StatusBar = function SpUiExtStatusBar ( container, config ) {
	config = config || {};

	// Mixin constructors
	OO.EventEmitter.call( this );

	this.container = container;
};

/* Inheritance */
OO.mixinClass( sp.ui.ext.StatusBar, OO.EventEmitter );

<span id='sp-ui-ext-Play-method-initialize'>/**
</span> * Initialize the Gui
 * @abstract
 * @throws {Error} If the method is not implemented in the child class
 * @returns {sp.ui.ext.Play}
 */
sp.ui.ext.StatusBar.prototype.initialize = function () {
	throw new Error( &#39;sp.Gui.Module.Initialize must be implemented in child class.&#39; );
};

<span id='sp-ui-ext-Play-property-ooui'>/**
</span> * UI OOUI Module namespace
 * @property {Object}
 */
sp.ui.ext.ooui = {
	&#39;Mod&#39;: {}
};

sp.ui.toolFactory = new OO.ui.ToolFactory();
sp.ui.toolGroupFactory = new OO.ui.ToolGroupFactory();

<span id='sp-ui-ext-ooui-Mod-Play'>/**
</span> * OOUI Gui module
 *
 * @class sp.ui.ext.ooui.Mod.Play
 *
 * @param {sp.Container} container The container to attach the GUI to
 * @param {Object} [config] Gui module definition
 */
sp.ui.ext.ooui.Mod.Play = function SpUiExtOouiModPlay( container, config ) {
	config = config || {};

	// Parent constructor
	sp.ui.ext.ooui.Mod.Play.super.call( this, container, config );

	this.tools = {};
	this.container = container;
	return this;
};

/* Inheritance */
OO.inheritClass( sp.ui.ext.ooui.Mod.Play, sp.ui.ext.Play );

/* Static */

<span id='sp-ui-ext-ooui-Mod-Play-property-toolbarGroups'>/**
</span> * Define toolbar groups for OOUI
 * @property {Array}
 */
sp.ui.ext.ooui.Mod.Play.static.toolbarGroups = [
	// Play tools
	{
		&#39;type&#39;: &#39;bar&#39;,
		&#39;include&#39;: [ { &#39;group&#39;: &#39;playTools&#39; } ],
		// TODO: Figure out a better organization for the toolbar
		&#39;exclude&#39;: [ &#39;pause&#39; ]
	},
	// POV menu
	{
		&#39;type&#39;: &#39;menu&#39;,
		&#39;indicator&#39;: &#39;down&#39;,
		&#39;label&#39;: &#39;POV&#39;,
		&#39;icon&#39;: &#39;picture&#39;,
		&#39;include&#39;: [ { &#39;group&#39;: &#39;povTools&#39; } ]
	},
	// View tools
	{
		&#39;type&#39;: &#39;bar&#39;,
		&#39;include&#39;: [ { &#39;group&#39;: &#39;zoomTools&#39; } ]
	},
	{
		&#39;type&#39;: &#39;bar&#39;,
		&#39;include&#39;: [ { &#39;group&#39;: &#39;viewTools&#39; } ],
		&#39;exclude&#39;: [ &#39;speed&#39; ]
	}
];

sp.ui.ext.ooui.Mod.Play.static.commands = [
	&#39;play&#39;,
	&#39;speed&#39;,
	&#39;zoomin&#39;,
	&#39;zoomout&#39;
];

/* Events */

<span id='sp-ui-ext-ooui-Mod-Play-event-play'>/**
</span> * Play or pause scenario
 * @event play
 * @param {boolean} isPlay Play scenario or pause
 */

<span id='sp-ui-ext-ooui-Mod-Play-event-zoom'>/**
</span> * Zoom in or out
 * @event zoom
 * @param {number} zoomLevel How much to zoom. Negative to zoom out.
 */

<span id='sp-ui-ext-ooui-Mod-Play-event-pov'>/**
</span> * Change point of view object
 * @event pov
 * @param {string} povObjName New POV object name or key
 */

/* Methods */

<span id='sp-ui-ext-ooui-Mod-Play-method-initialize'>/**
</span> * Initialize the Gui
 * @returns {sp.ui.ext.ooui.Mod.Play}
 */
sp.ui.ext.ooui.Mod.Play.prototype.initialize = function () {
	var i, tools, tname;

	// Call parent
	sp.ui.ext.Play.prototype.initialize.call( this );

	this.toolbar = new sp.ui.ext.ooui.Toolbar( this, this.container );
	this.toolbar.setup( this.constructor.static.toolbarGroups );
	// TODO: Add commands to container (future!)
//	this.container.addCommands( this.constructor.static.commands );
	this.container.addToolbar( this.toolbar.$element );

	this.toolbar.emit( &#39;updateState&#39; );

	// Events
	this.container.connect( this, { &#39;scenarioLoaded&#39;: &#39;onScenarioLoaded&#39; } );

	return this;
};

<span id='sp-ui-ext-ooui-Mod-Play-method-onScenarioLoaded'>/**
</span> * Respond to new scenario loaded
 * @fires updateState
 */
sp.ui.ext.ooui.Mod.Play.prototype.onScenarioLoaded = function () {
	if ( this.container.getScenario() ) {
		this.container.getScenario().disconnect( this );
	}
	// Events
	this.container.getScenario().connect( this, { &#39;pause&#39;: [ &#39;onScenarioChanged&#39;, &#39;play&#39; ] } );
	this.container.getScenario().connect( this, { &#39;pov&#39;: [ &#39;onScenarioChanged&#39;, &#39;pov&#39; ] } );
	this.container.getScenario().connect( this, { &#39;grid&#39;: [ &#39;onScenarioChanged&#39;, &#39;grid&#39; ] } );

	// Update the toolbar
	this.toolbar.emit( &#39;updateState&#39; );
};

<span id='sp-ui-ext-ooui-Mod-Play-method-onScenarioChanged'>/**
</span> * Respond to change in scenario state
 * @fires updateState
 */
sp.ui.ext.ooui.Mod.Play.prototype.onScenarioChanged = function () {
	this.toolbar.emit( &#39;updateState&#39;, arguments );
};

<span id='sp-ui-ext-ooui-Mod-Play-method-addToPOVList'>/**
</span> * Add a tool to the POV list
 * @param {string} name Tool name
 * @param {string} title Title or alternate text
 * @param {string} [icon] Tool icon
 */
sp.ui.ext.ooui.Mod.Play.prototype.addToPOVList = function ( name, title, icon ) {
	var tool, toolDefinition;

	icon = icon || &#39;picture&#39;;
	toolDefinition = [
		// name
		name,
		// icon
		icon,
		// title/label
		title
	];

	tool = this.createPOVTool.apply( this, toolDefinition );
	sp.ui.toolFactory.register( tool );
};

<span id='sp-ui-ext-ooui-Mod-Play-method-getToolbar'>/**
</span> * Get the Gui toolbar
 * @returns {OO.ui.Toolbar} The toolbar connected to the gui
 */
sp.ui.ext.ooui.Mod.Play.prototype.getToolbar = function () {
	return this.toolbar;
};

<span id='sp-ui-ext-ooui-Mod-Play-method-createPOVTool'>/**
</span> * Create a POV tool
 * @param {string} name Tool name
 * @param {string} icon Tool icon
 * @param {string} title Title or alternate text
 * @returns {sp.ui.ext.ooui.POVTool} Tool
 */
sp.ui.ext.ooui.Mod.Play.prototype.createPOVTool = function ( name, icon, title ) {
	var Tool = function SpGuiPOVTool() {
		Tool.super.apply( this, arguments );
	};
	OO.inheritClass( Tool, sp.ui.ext.ooui.POVTool );

	Tool.static.name = name;
	Tool.static.icon = icon;
	Tool.static.title = title;
	return Tool;
};

<span id='sp-ui-ext-ooui-Toolbar-method-constructor'><span id='sp-ui-ext-ooui-Toolbar'>/**
</span></span> * OOUI Module Toolbar.
 *
 * @class
 * @constructor
 * @extends OO.ui.Toolbar
 *
 * @param {sp.ui.ext.Play} target The UI controller
 * @param {sp.Container} container The container this toolbar is attached to
 * @param {Object} [config] Optional configuration options.
 */
sp.ui.ext.ooui.Toolbar = function SpUiExtOouiToolbar( target, container, config ) {
	// Parent constructor
	OO.ui.Toolbar.call(
		this,
		sp.ui.toolFactory,
		sp.ui.toolGroupFactory,
		config
	);

	this.target = target;
	this.container = container;
	this.container.connect( this, { &#39;addCommand&#39;: &#39;onContainerAddCommand&#39; } );
};

/* Inheritance */
OO.inheritClass( sp.ui.ext.ooui.Toolbar, OO.ui.Toolbar );

<span id='sp-ui-ext-ooui-Toolbar-method-getContainer'>/**
</span> * Get the container attached to this toolbar
 * @returns {sp.Container} Container
 */
sp.ui.ext.ooui.Toolbar.prototype.getContainer = function () {
	return this.container;
};

<span id='sp-ui-ext-ooui-Toolbar-method-onContainerAddCommand'>/**
</span> * Handle command being added to surface.
 *
 * If a matching tool is present, it&#39;s label will be updated.
 *
 * @param {string} name Symbolic name of command and trigger
 */
sp.ui.ext.ooui.Toolbar.prototype.onContainerAddCommand = function ( name ) {
	if ( this.tools[name] ) {
		this.tools[name].updateTitle();
	}
};

sp.ui.ext.ooui.Toolbar.prototype.onMouseDown = function ( e ) {
};

<span id='sp-ui-ext-ooui-Tool-method-constructor'><span id='sp-ui-ext-ooui-Tool'>/**
</span></span> * Regular button tool.
 *
 * @class
 * @extends OO.ui.Tool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.Tool = function SpUiExtOouiTool( toolGroup, config ) {
	// Parent constructor
	OO.ui.Tool.call( this, toolGroup, config );
};

/* Inheritance */

OO.inheritClass( sp.ui.ext.ooui.Tool, OO.ui.Tool );

/* Methods */

<span id='sp-ui-ext-ooui-Tool-method-onUpdateState'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.Tool.prototype.onUpdateState = function () {
	this.setDisabled( !this.toolbar.getContainer().getScenario() );
};

<span id='sp-ui-ext-ooui-Tool-method-onSelect'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.Tool.prototype.onSelect = function () {
	if ( this.constructor.static.deactivateOnSelect ) {
		this.setActive( false );
	}
};

<span id='sp-ui-ext-ooui-PlayTool-method-constructor'><span id='sp-ui-ext-ooui-PlayTool'>/**
</span></span> * UserInterface play tool.
 *
 * @class
 * @extends sp.ui.ext.ooui.Tool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.PlayTool = function SpUiExtOouiPlayTool( toolGroup, config ) {
	sp.ui.ext.ooui.Tool.call( this, toolGroup, config );
};
OO.inheritClass( sp.ui.ext.ooui.PlayTool, sp.ui.ext.ooui.Tool );
sp.ui.ext.ooui.PlayTool.static.name = &#39;play&#39;;
sp.ui.ext.ooui.PlayTool.static.group = &#39;playTools&#39;;
sp.ui.ext.ooui.PlayTool.static.icon = &#39;play&#39;;
sp.ui.ext.ooui.PlayTool.static.title = &#39;Play&#39;;
sp.ui.ext.ooui.PlayTool.static.commandName = &#39;play&#39;;

<span id='sp-ui-ext-ooui-PlayTool-method-onUpdateState'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.PlayTool.prototype.onUpdateState = function () {
	var isPaused = false;
	// Parent
	sp.ui.ext.ooui.Tool.prototype.onUpdateState.apply( this, arguments );

	if ( this.toolbar.getContainer().getScenario() ) {
		this.setActive( !this.toolbar.getContainer().getScenario().isPaused() );
	}
};

<span id='sp-ui-ext-ooui-PlayTool-method-onSelect'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.PlayTool.prototype.onSelect = function () {
	// Pause the scenario
	this.toolbar.getContainer().getScenario().togglePaused();
};

sp.ui.toolFactory.register( sp.ui.ext.ooui.PlayTool );

<span id='sp-ui-ext-ooui-PauseTool-method-constructor'><span id='sp-ui-ext-ooui-PauseTool'>/**
</span></span> * UserInterface pause tool.
 *
 * @class
 * @extends sp.ui.ext.ooui.Tool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.PauseTool = function SpUiExtOouiPauseTool( toolGroup, config ) {
	sp.ui.ext.ooui.Tool.call( this, toolGroup, config );
};
OO.inheritClass( sp.ui.ext.ooui.PauseTool, sp.ui.ext.ooui.Tool );
sp.ui.ext.ooui.PauseTool.static.name = &#39;pause&#39;;
sp.ui.ext.ooui.PauseTool.static.group = &#39;playTools&#39;;
sp.ui.ext.ooui.PauseTool.static.icon = &#39;pause&#39;;
sp.ui.ext.ooui.PauseTool.static.title = &#39;pause&#39;;
sp.ui.ext.ooui.PauseTool.static.commandName = &#39;pause&#39;;

<span id='sp-ui-ext-ooui-PauseTool-method-onUpdateState'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.PauseTool.prototype.onUpdateState = function () {
	var isPaused = false;
	// Parent
	sp.ui.ext.ooui.Tool.prototype.onUpdateState.apply( this, arguments );

	if ( this.toolbar.getContainer().getScenario() ) {
		this.setActive( this.toolbar.getContainer().getScenario().isPaused() );
	}
};

<span id='sp-ui-ext-ooui-PauseTool-method-onSelect'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.PauseTool.prototype.onSelect = function () {
	// Pause the scenario
	this.toolbar.getContainer().getScenario().togglePaused();
};

sp.ui.toolFactory.register( sp.ui.ext.ooui.PauseTool );

<span id='sp-ui-ext-ooui-ZoomTool-method-constructor'><span id='sp-ui-ext-ooui-ZoomTool'>/**
</span></span> * UserInterface zoom in tool.
 *
 * @class
 * @extends sp.ui.ext.ooui.Tool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.ZoomTool = function SpUiExtOouiZoomTool( toolGroup, config ) {
	sp.ui.ext.ooui.Tool.call( this, toolGroup, config );
};
OO.inheritClass( sp.ui.ext.ooui.ZoomTool, sp.ui.ext.ooui.Tool );
sp.ui.ext.ooui.ZoomTool.static.group = &#39;zoomTools&#39;;
sp.ui.ext.ooui.ZoomTool.static.deactivateOnSelect = true;
<span id='sp-ui-ext-ooui-ZoomTool-method-onUpdateState'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.ZoomTool.prototype.onUpdateState = function () {
	// Parent
	sp.ui.ext.ooui.Tool.prototype.onUpdateState.apply( this, arguments );
	this.setDisabled( !!!this.toolbar.getContainer().getScenario() );
};

<span id='sp-ui-ext-ooui-ZoomTool-method-onSelect'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.ZoomTool.prototype.onSelect = function ( zoom ) {
	this.toolbar.getContainer().getScenario().setZoom( zoom );
	// Parent
	sp.ui.ext.ooui.Tool.prototype.onSelect.call( this );
};

<span id='sp-ui-ext-ooui-ZoomInTool-method-constructor'><span id='sp-ui-ext-ooui-ZoomInTool'>/**
</span></span> * UserInterface zoom in tool.
 *
 * @class
 * @extends sp.ui.ext.ooui.ZoomTool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.ZoomInTool = function SpUiExtOouiZoomInTool( toolGroup, config ) {
	sp.ui.ext.ooui.ZoomTool.call( this, toolGroup, config );
};
OO.inheritClass( sp.ui.ext.ooui.ZoomInTool, sp.ui.ext.ooui.ZoomTool );
sp.ui.ext.ooui.ZoomInTool.static.name = &#39;zoomin&#39;;
sp.ui.ext.ooui.ZoomInTool.static.icon = &#39;zoomin&#39;;
sp.ui.ext.ooui.ZoomInTool.static.title = &#39;Zoom in&#39;;
sp.ui.ext.ooui.ZoomInTool.static.commandName = &#39;zoomin&#39;;

<span id='sp-ui-ext-ooui-ZoomInTool-method-onSelect'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.ZoomInTool.prototype.onSelect = function () {
	// Parent
	sp.ui.ext.ooui.ZoomTool.prototype.onSelect.apply( this, [ 1000 ] );
};

sp.ui.toolFactory.register( sp.ui.ext.ooui.ZoomInTool );

<span id='sp-ui-ext-ooui-ZoomOutTool-method-constructor'><span id='sp-ui-ext-ooui-ZoomOutTool'>/**
</span></span> * UserInterface zoom out tool.
 *
 * @class
 * @extends sp.ui.ext.ooui.ZoomTool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.ZoomOutTool = function SpUiExtOouiZoomOutTool( toolGroup, config ) {
	sp.ui.ext.ooui.ZoomTool.call( this, toolGroup, config );
};
OO.inheritClass( sp.ui.ext.ooui.ZoomOutTool, sp.ui.ext.ooui.ZoomTool );
sp.ui.ext.ooui.ZoomOutTool.static.name = &#39;zoomout&#39;;
sp.ui.ext.ooui.ZoomOutTool.static.icon = &#39;zoomout&#39;;
sp.ui.ext.ooui.ZoomOutTool.static.title = &#39;Zoom out&#39;;
sp.ui.ext.ooui.ZoomOutTool.static.commandName = &#39;zoomout&#39;;

<span id='sp-ui-ext-ooui-ZoomOutTool-method-onSelect'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.ZoomOutTool.prototype.onSelect = function () {
	// Parent
	sp.ui.ext.ooui.ZoomTool.prototype.onSelect.apply( this, [ -1000 ] );
};

sp.ui.toolFactory.register( sp.ui.ext.ooui.ZoomOutTool );

<span id='sp-ui-ext-ooui-GridTool-method-constructor'><span id='sp-ui-ext-ooui-GridTool'>/**
</span></span> * UserInterface grid tool.
 *
 * @class
 * @extends sp.ui.ext.ooui.Tool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.GridTool = function SpUiExtOouiGridTool( toolGroup, config ) {
	sp.ui.ext.ooui.Tool.call( this, toolGroup, config );
};
OO.inheritClass( sp.ui.ext.ooui.GridTool, sp.ui.ext.ooui.Tool );
sp.ui.ext.ooui.GridTool.static.name = &#39;grid&#39;;
sp.ui.ext.ooui.GridTool.static.group = &#39;viewTools&#39;;
sp.ui.ext.ooui.GridTool.static.icon = &#39;grid&#39;;
sp.ui.ext.ooui.GridTool.static.title = &#39;grid&#39;;
sp.ui.ext.ooui.GridTool.static.commandName = &#39;grid&#39;;

<span id='sp-ui-ext-ooui-GridTool-method-onUpdateState'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.GridTool.prototype.onUpdateState = function () {
	var isPaused = false;
	// Parent
	sp.ui.ext.ooui.Tool.prototype.onUpdateState.apply( this, arguments );

	if ( this.toolbar.getContainer().getScenario() ) {
		this.setActive( this.toolbar.getContainer().getScenario().isShowGrid() );
	}
};

<span id='sp-ui-ext-ooui-GridTool-method-onSelect'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.GridTool.prototype.onSelect = function () {
	// toggle grid
	this.toolbar.getContainer().getScenario().toggleGrid();
};

sp.ui.toolFactory.register( sp.ui.ext.ooui.GridTool );

<span id='sp-ui-ext-ooui-PitchTool-method-constructor'><span id='sp-ui-ext-ooui-PitchTool'>/**
</span></span> * UserInterface zoom in tool.
 *
 * @class
 * @extends sp.ui.ext.ooui.Tool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.PitchTool = function SpUiExtOouiPitchTool( toolGroup, config ) {
	sp.ui.ext.ooui.Tool.call( this, toolGroup, config );
};
OO.inheritClass( sp.ui.ext.ooui.PitchTool, sp.ui.ext.ooui.Tool );
sp.ui.ext.ooui.PitchTool.static.group = &#39;viewTools&#39;;
sp.ui.ext.ooui.PitchTool.static.deactivateOnSelect = true;
<span id='sp-ui-ext-ooui-PitchTool-method-onUpdateState'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.PitchTool.prototype.onUpdateState = function () {
	// Parent
	sp.ui.ext.ooui.Tool.prototype.onUpdateState.apply( this, arguments );
	this.setDisabled( !!!this.toolbar.getContainer().getScenario() );
};

<span id='sp-ui-ext-ooui-PitchTool-method-onSelect'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.PitchTool.prototype.onSelect = function () {
	var toDeg = 180 / Math.PI,
		toRadians = Math.PI / 180,
		scenario = this.toolbar.getContainer().getScenario();

	// Change to degrees so we can increase/decrease
	pitch = Math.floor( scenario.getPitchAngle() * toDeg );
	pitch += this.constructor.static.changeAngle;

	// Change pitch (back to radians)
	this.toolbar.getContainer().getScenario().setPitchAngle( pitch * toRadians );
	// Parent
	sp.ui.ext.ooui.Tool.prototype.onSelect.call( this );
};

<span id='sp-ui-ext-ooui-TiltUpTool-method-constructor'><span id='sp-ui-ext-ooui-TiltUpTool'>/**
</span></span> * UserInterface tilt up tool
 *
 * @class
 * @extends sp.ui.ext.ooui.PitchTool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.TiltUpTool = function SpUiExtOouiZoomInTool( toolGroup, config ) {
	sp.ui.ext.ooui.PitchTool.call( this, toolGroup, config );
};
OO.inheritClass( sp.ui.ext.ooui.TiltUpTool, sp.ui.ext.ooui.PitchTool );
sp.ui.ext.ooui.TiltUpTool.static.name = &#39;tiltup&#39;;
sp.ui.ext.ooui.TiltUpTool.static.icon = &#39;tiltup&#39;;
sp.ui.ext.ooui.TiltUpTool.static.title = &#39;Tilt up&#39;;
sp.ui.ext.ooui.TiltUpTool.static.changeAngle = 10;
sp.ui.ext.ooui.TiltUpTool.static.commandName = &#39;tiltup&#39;;

sp.ui.toolFactory.register( sp.ui.ext.ooui.TiltUpTool );

<span id='sp-ui-ext-ooui-TiltDownTool-method-constructor'><span id='sp-ui-ext-ooui-TiltDownTool'>/**
</span></span> * UserInterface tilt down tool
 *
 * @class
 * @extends sp.ui.ext.ooui.PitchTool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.TiltDownTool = function SpUiExtOouiZoomInTool( toolGroup, config ) {
	sp.ui.ext.ooui.PitchTool.call( this, toolGroup, config );
};
OO.inheritClass( sp.ui.ext.ooui.TiltDownTool, sp.ui.ext.ooui.PitchTool );
sp.ui.ext.ooui.TiltDownTool.static.name = &#39;tiltdown&#39;;
sp.ui.ext.ooui.TiltDownTool.static.icon = &#39;tiltdown&#39;;
sp.ui.ext.ooui.TiltDownTool.static.title = &#39;Tilt down&#39;;
sp.ui.ext.ooui.TiltDownTool.static.changeAngle = -10;
sp.ui.ext.ooui.TiltDownTool.static.commandName = &#39;tiltdown&#39;;

sp.ui.toolFactory.register( sp.ui.ext.ooui.TiltDownTool );

<span id='sp-ui-ext-ooui-LabelTool-method-constructor'><span id='sp-ui-ext-ooui-LabelTool'>/**
</span></span> * Label tool.
 *
 * @class
 * @extends OO.ui.Tool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.LabelTool = function SpUiExtOouiLabelTool( toolGroup, config ) {
	// Parent constructor
	OO.ui.Tool.call( this, toolGroup, config );
	// Mixin constructor
	OO.ui.LabeledElement.call( this, $( &#39;&lt;div&gt;&#39; ), config );

	this.$element.empty();
	this.$element.append( this.$label.show() );
};

/* Inheritance */

OO.inheritClass( sp.ui.ext.ooui.LabelTool, OO.ui.Tool );
OO.mixinClass( sp.ui.ext.ooui.LabelTool, OO.ui.LabeledElement );

/* Methods */

<span id='sp-ui-ext-ooui-LabelTool-method-onUpdateState'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.LabelTool.prototype.onUpdateState = function () {
	this.setDisabled( !this.toolbar.getContainer().getScenario() );
};

<span id='sp-ui-ext-ooui-ZoomLabelTool-method-constructor'><span id='sp-ui-ext-ooui-ZoomLabelTool'>/**
</span></span> * UserInterface play tool.
 *
 * @class
 * @extends sp.ui.ext.ooui.Tool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.ZoomLabelTool = function SpUiExtOouiZoomLabelTool( toolGroup, config ) {
	sp.ui.ext.ooui.LabelTool.call( this, toolGroup, config );
};
OO.inheritClass( sp.ui.ext.ooui.ZoomLabelTool, sp.ui.ext.ooui.LabelTool );
sp.ui.ext.ooui.ZoomLabelTool.static.name = &#39;zoomLabel&#39;;
sp.ui.ext.ooui.ZoomLabelTool.static.group = &#39;zoomTools&#39;;
sp.ui.ext.ooui.ZoomLabelTool.static.title = &#39;Zoom&#39;;

<span id='sp-ui-ext-ooui-ZoomLabelTool-method-onUpdateState'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.ZoomLabelTool.prototype.onUpdateState = function () {
	// Parent
	sp.ui.ext.ooui.LabelTool.prototype.onUpdateState.apply( this, arguments );

	if ( this.toolbar.getContainer().getScenario() ) {
		this.setLabel( this.toolbar.getContainer().getScenario().getZoom() );
	}
};

<span id='sp-ui-ext-ooui-ZoomLabelTool-method-onSelect'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.ZoomLabelTool.prototype.onSelect = function () {
	return false;
};

sp.ui.toolFactory.register( sp.ui.ext.ooui.ZoomLabelTool );

<span id='sp-ui-ext-ooui-POVTool-method-constructor'><span id='sp-ui-ext-ooui-POVTool'>/**
</span></span> * Regular POV list tool.
 *
 * @class
 * @extends OO.ui.Tool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.POVTool = function SpUiExtOouiPOVTool( toolGroup, config ) {
	// Parent constructor
	OO.ui.Tool.call( this, toolGroup, config );
};

/* Inheritance */

OO.inheritClass( sp.ui.ext.ooui.POVTool, OO.ui.Tool );

/* Static */

sp.ui.ext.ooui.POVTool.static.group = &#39;povTools&#39;;

/* Methods */

<span id='sp-ui-ext-ooui-POVTool-method-onUpdateState'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.POVTool.prototype.onUpdateState = function () {
	var currPov;
	this.setDisabled( !this.toolbar.getContainer().getScenario() );

	if ( this.toolbar.getContainer().getScenario() ) {
		currPov = this.toolbar.getContainer().getScenario().getPOV();
		this.setActive( currPov === this.constructor.static.name );
	}
};

<span id='sp-ui-ext-ooui-POVTool-method-onSelect'>/**
</span> * @inheritdoc
 */
sp.ui.ext.ooui.POVTool.prototype.onSelect = function () {
	if ( this.toolbar.getContainer().getScenario() ) {
		this.toolbar.getContainer().getScenario().setPOV(
			this.constructor.static.name
		);
	}
};

<span id='sp-ui-ext-ooui-SliderTool-method-constructor'><span id='sp-ui-ext-ooui-SliderTool'>/**
</span></span> * A slider tool
 *
 * @class
 * @extends OO.ui.Tool
 *
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.SliderTool = function SpUiExtOouiSliderTool( toolGroup, config ) {
	// Parent constructor
	sp.ui.ext.ooui.Tool.call( this, toolGroup, config );

	// Initialization
	this.$element.empty();
	this.$slider = this.$( &#39;&lt;input&gt;&#39; )
		.addClass( &#39;sp-ui-ooui-sliderHandle&#39; )
		.attr( &#39;type&#39;, &#39;range&#39; )
		.attr( &#39;min&#39;, &#39;1&#39; )
		.attr( &#39;max&#39;, &#39;100&#39; );

	this.$element
		.addClass( &#39;sp-ui-ooui-sliderTool&#39; )
		.append( this.$slider );
};

/* Setup */

OO.inheritClass( sp.ui.ext.ooui.SliderTool, sp.ui.ext.ooui.Tool );

/* Methods */
sp.ui.ext.ooui.SliderTool.prototype.onUpdateState = function () {
	// Parent
	sp.ui.ext.ooui.Tool.prototype.onUpdateState.apply( this, arguments );
};

<span id='sp-ui-ext-ooui-SpeedSliderTool-method-constructor'><span id='sp-ui-ext-ooui-SpeedSliderTool'>/**
</span></span> * UserInterface zoom tool.
 *
 * @class
 * @extends sp.ui.ext.ooui.SliderTool
 * @constructor
 * @param {OO.ui.ToolGroup} toolGroup
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.ooui.SpeedSliderTool = function SpUiExtOouiZoomSliderTool( toolGroup, config ) {
	sp.ui.ext.ooui.SliderTool.call( this, toolGroup, config );
	this.$element.addClass( &#39;sp-ui-ooui-speedSlider&#39; );
};
OO.inheritClass( sp.ui.ext.ooui.SpeedSliderTool, sp.ui.ext.ooui.Tool );
sp.ui.ext.ooui.SpeedSliderTool.static.name = &#39;speed&#39;;
sp.ui.ext.ooui.SpeedSliderTool.static.group = &#39;viewTools&#39;;
sp.ui.ext.ooui.SpeedSliderTool.static.icon = &#39;speed&#39;;
sp.ui.ext.ooui.SpeedSliderTool.static.title = &#39;speed&#39;;
sp.ui.ext.ooui.SpeedSliderTool.static.commandName = &#39;speed&#39;;

sp.ui.toolFactory.register( sp.ui.ext.ooui.SpeedSliderTool );

<span id='sp-ui-ext-ooui-SpeedSliderTool-property-jqueryui'>/**
</span> * UI jQueryUI Module namespace
 * @property {Object}
 */
sp.ui.ext.jqueryui = {
	&#39;Mod&#39;: {}
};

<span id='sp-ui-ext-jqueryui-Mod-Play'>/**
</span> * jQueryUI Gui module
 *
 * @class sp.ui.ext.jqueryui.Mod.Play
 *
 * @param {sp.Container} container The container to attach the GUI to
 * @param {Object} [config] Gui module definition
 */
sp.ui.ext.jqueryui.Mod.Play = function SpUiExtJqueryUiModPlay( container, config ) {
	config = config || {};

	// Parent constructor
	sp.ui.ext.jqueryui.Mod.Play.super.call( this, container, config );

	this.buttonSets = {};
	this.buttons = {};

	this.statusBar = new sp.ui.ext.jqueryui.Mod.StatusBar( container, config );

	// Events
	this.container.connect( this, { &#39;scenarioLoaded&#39;: &#39;onScenarioLoaded&#39; } );
};

/* Inheritance */
OO.inheritClass( sp.ui.ext.jqueryui.Mod.Play, sp.ui.ext.Play );

/* Static */

/* Events */

<span id='sp-ui-ext-jqueryui-Mod-Play-event-play'>/**
</span> * Play or pause scenario
 * @event play
 * @param {boolean} isPlay Play scenario or pause
 */

<span id='sp-ui-ext-jqueryui-Mod-Play-event-zoom'>/**
</span> * Zoom in or out
 * @event zoom
 * @param {number} zoomLevel How much to zoom. Negative to zoom out.
 */

<span id='sp-ui-ext-jqueryui-Mod-Play-event-pov'>/**
</span> * Change point of view object
 * @event pov
 * @param {string} povObjName New POV object name or key
 */

/* Methods */

<span id='sp-ui-ext-jqueryui-Mod-Play-method-initialize'>/**
</span> * Initialize the Gui
 * @returns {sp.ui.ext.jqueryui.Mod.Play}
 */
sp.ui.ext.jqueryui.Mod.Play.prototype.initialize = function () {
	var tool,
		$separator = $( &#39;&lt;div&gt;&#39; )
			.addClass( &#39;sp-ui-jqueryui-sep&#39; );

	this.$toolbar = $( &#39;&lt;div&gt;&#39; )
		.addClass( &#39;sp-ui-jqueryui-toolbar&#39; );

	this.buttonSets = {};
	this.buttons = {};
	this.labels = {};

	// Add buttons
	this.buttons.play = new sp.ui.ext.jqueryui.CheckButtonTool( {
		&#39;name&#39;: &#39;play&#39;,
		&#39;icon&#39;: &#39;play&#39;
	} );

	this.buttons.povList = new sp.ui.ext.jqueryui.SelectTool( {
		&#39;name&#39;: &#39;pov&#39;
	} );

	this.buttons.zoomin = new sp.ui.ext.jqueryui.ClickButtonTool( {
		&#39;name&#39;: &#39;zoomin&#39;,
		&#39;icon&#39;: &#39;zoomin&#39;,
		&#39;action&#39;: 1000
	} );

	this.buttons.zoomout = new sp.ui.ext.jqueryui.ClickButtonTool( {
		&#39;name&#39;: &#39;zoomout&#39;,
		&#39;icon&#39;: &#39;zoomout&#39;,
		&#39;action&#39;: -1000
	} );

	this.buttons.grid = new sp.ui.ext.jqueryui.CheckButtonTool( {
		&#39;name&#39;: &#39;grid&#39;,
		&#39;icon&#39;: &#39;grid&#39;
	} );

	this.$toolbar.append( [
		this.buttons.play.$element,
		$separator.clone(),
		this.buttons.povList.$element,
		$separator.clone(),
		this.buttons.zoomin.$element,
		this.buttons.zoomout.$element,
		$separator.clone(),
		this.buttons.grid.$element
	] );

	this.container.addToolbar( this.$toolbar );

	// Status bar
	this.labels.zoom = new sp.ui.ext.jqueryui.LabelTool( {
		&#39;label&#39;: &#39;Zoom level&#39;
	} );
	this.statusBar.$element.append( [
		this.labels.zoom.$element
	] );

	this.container.addToolbar( this.statusBar.$element, &#39;bottom&#39; );

	this.buttons.play.connect( this, { &#39;change&#39;: &#39;onPlayChange&#39; } );
	this.buttons.povList.connect( this, { &#39;change&#39;: &#39;onPovChange&#39; } );
	this.buttons.zoomin.connect( this, { &#39;click&#39;: &#39;onZoomClick&#39; } );
	this.buttons.zoomout.connect( this, { &#39;click&#39;: &#39;onZoomClick&#39; } );
	this.buttons.grid.connect( this, { &#39;change&#39;: &#39;onGridChange&#39; } );

	return this;
};

<span id='sp-ui-ext-jqueryui-Mod-Play-method-onScenarioLoaded'>/**
</span> * Respond to new scenario loaded
 * @fires updateState
 */
sp.ui.ext.jqueryui.Mod.Play.prototype.onScenarioLoaded = function () {
	if ( this.container.getScenario() ) {
		this.container.getScenario().disconnect( this );
	}
	// Events
	this.container.getScenario().connect( this, { &#39;pause&#39;: [ &#39;onScenarioChanged&#39;, &#39;pause&#39; ] } );
	this.container.getScenario().connect( this, { &#39;pov&#39;: [ &#39;onScenarioChanged&#39;, &#39;pov&#39; ] } );
	this.container.getScenario().connect( this, { &#39;grid&#39;: [ &#39;onScenarioChanged&#39;, &#39;grid&#39; ] } );
	this.container.getScenario().connect( this, { &#39;zoom&#39;: [ &#39;onScenarioChanged&#39;, &#39;zoom&#39; ] } );

	// Update POV
	this.buttons.play.setValue( !this.container.getScenario().isPaused() );
	this.buttons.povList.setValue( this.container.getScenario().getPOV() );
	this.buttons.grid.setValue( this.container.getScenario().isShowGrid() );
	this.labels.zoom.setValue( this.container.getScenario().getZoom() );
};

<span id='sp-ui-ext-jqueryui-Mod-Play-method-onScenarioChanged'>/**
</span> * Respond to change in scenario state
 * @fires updateState
 */
sp.ui.ext.jqueryui.Mod.Play.prototype.onScenarioChanged = function ( action, status ) {
	switch ( action ) {
		case &#39;pause&#39;:
			this.buttons.play.setValue( !status );
			break;
		case &#39;pov&#39;:
			this.buttons.povList.setValue( status );
			break;
		case &#39;grid&#39;:
			this.buttons.grid.setValue( status );
			break;
		case &#39;zoom&#39;:
			this.labels.zoom.setValue( this.container.getScenario().getZoom() );
			break;
	}
};

<span id='sp-ui-ext-jqueryui-Mod-Play-method-onPlayChange'>/**
</span> * Respond to play button change
 * @param {Boolean} isPlay Play scenario
 */
sp.ui.ext.jqueryui.Mod.Play.prototype.onPlayChange = function ( isPlay ) {
	this.container.getScenario().togglePaused( !isPlay );
};

<span id='sp-ui-ext-jqueryui-Mod-Play-method-onZoomClick'>/**
</span> * Respond to zoom buttons change
 * @param {number} zoomFactor Zoom factor
 */
sp.ui.ext.jqueryui.Mod.Play.prototype.onZoomClick = function ( zoomFactor ) {
	this.container.getScenario().setZoom( zoomFactor );
};

<span id='sp-ui-ext-jqueryui-Mod-Play-method-onPovChange'>/**
</span> * Respond to pov change
 * @param {string} pov New POV item
 */
sp.ui.ext.jqueryui.Mod.Play.prototype.onPovChange = function ( pov ) {
	this.container.getScenario().setPOV( pov );
};

<span id='sp-ui-ext-jqueryui-Mod-Play-method-onGridChange'>/**
</span> * Respond to grid button change
 * @param {Boolean} isGrid Show grid
 */
sp.ui.ext.jqueryui.Mod.Play.prototype.onGridChange = function ( isGrid ) {
	this.container.getScenario().toggleGrid( isGrid );
};
<span id='sp-ui-ext-jqueryui-Mod-Play-method-addToPOVList'>/**
</span> * Add a tool to the POV list
 * @param {string} name Tool name
 * @param {string} title Title or alternate text
 * @param {string} [icon] Tool icon
 */
sp.ui.ext.jqueryui.Mod.Play.prototype.addToPOVList = function ( name, title, icon ) {
	this.buttons.povList.addOption( name, title );
};

<span id='sp-ui-ext-jqueryui-Mod-Play'>/**
</span> * jQueryUI Gui module
 *
 * @class sp.ui.ext.jqueryui.Mod.Play
 *
 * @param {sp.Container} container The container to attach the GUI to
 * @param {Object} [config] Gui module definition
 */
sp.ui.ext.jqueryui.Mod.StatusBar = function SpUiExtJqueryUiModStatusBar( container, config ) {
	var $separator = $( &#39;&lt;div&gt;&#39; )
			.addClass( &#39;sp-ui-jqueryui-sep&#39; );

	config = config || {};

	// Parent constructor
	sp.ui.ext.jqueryui.Mod.StatusBar.super.call( this, container, config );

	this.$element = $( &#39;&lt;div&gt;&#39; )
		.addClass( &#39;sp-ui-jqueryui-statusbar&#39; );

	// Events
//	this.container.connect( this, { &#39;scenarioLoaded&#39;: &#39;onScenarioLoaded&#39; } );
};

/* Inheritance */
OO.inheritClass( sp.ui.ext.jqueryui.Mod.StatusBar, sp.ui.ext.StatusBar );

<span id='sp-ui-ext-jqueryui-Buttonset-method-constructor'><span id='sp-ui-ext-jqueryui-Buttonset'>/**
</span></span> * jQueryUI toolset.
 *
 * @class
 * @constructor
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.jqueryui.Buttonset = function SpUiExtJqueryUiButtonset( config ) {
	var tool;

	config = config || {};

	this.$element = $( &#39;&lt;div&gt;&#39; )
		.addClass( &#39;sp-ui-jqueryui-toolset&#39; );

	if ( config.name ) {
		this.$element.addClass( &#39;sp-ui-jqueryui-toolset-&#39; + config.name );
	}

	this.tools = config.tools || [];

	this.$element.buttonset();
};

<span id='sp-ui-ext-jqueryui-Buttonset-method-addButton'>/**
</span> * Add tool to toolset
 * @param {[type]} tool [description]
 */
sp.ui.ext.jqueryui.Buttonset.prototype.addButton = function ( tool ) {
	this.tools.push( tool );
	this.$element.append( tool.$element );
};

<span id='sp-ui-ext-jqueryui-ClickButtonTool-method-constructor'><span id='sp-ui-ext-jqueryui-ClickButtonTool'>/**
</span></span> * jQueryUI click tool.
 *
 * @class
 * @constructor
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.jqueryui.ClickButtonTool = function SpUiExtJqueryUiClickButtonTool( config ) {
	config = config || {};

	// Mixin constructors
	OO.EventEmitter.call( this );

	this.name = config.name || &#39;general&#39;;
	this.action = config.action;

	this.$element = $( &#39;&lt;button&gt;&#39; )
		.prop( &#39;id&#39;, &#39;sp-ui-jqueryui-tool-&#39; + this.name )
		.addClass( &#39;sp-ui-jqueryui-clickButtonTool&#39; );

	if ( config.icon ) {
		this.$element.addClass( &#39;sp-ui-jqueryui-tool-icon sp-ui-jqueryui-icon-&#39; + config.icon );
	}

	if ( config.label ) {
		this.$element.text( config.label );
	}

	// Events
	this.$element.on( &#39;click&#39;, $.proxy( this.onClick , this ) );

	this.$element.button();
};

/* Inheritance */

OO.inheritClass( sp.ui.ext.jqueryui.ClickButtonTool, OO.EventEmitter );

/* Events */

<span id='sp-ui-ext-jqueryui-ClickButtonTool-event-click'>/**
</span> * Button click
 * @event click
 */

/* Methods */

<span id='sp-ui-ext-jqueryui-ClickButtonTool-method-onClick'>/**
</span> * Respond to a click event
 * @param {jQuery.event} event Click event
 * @fires click
 */
sp.ui.ext.jqueryui.ClickButtonTool.prototype.onClick = function ( event ) {
	this.emit( &#39;click&#39;, this.action );
	event.preventDefault();
};

<span id='sp-ui-ext-jqueryui-CheckButtonTool-method-constructor'><span id='sp-ui-ext-jqueryui-CheckButtonTool'>/**
</span></span> * jQueryUI check tool.
 *
 * @class
 * @constructor
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.jqueryui.CheckButtonTool = function SpUiExtJqueryUiCheckButtonTool( config ) {
	config = config || {};
	// Mixin constructors
	OO.EventEmitter.call( this );

	this.value = false;
	this.name = config.name || &#39;general&#39;;

	this.$checkbox = $( &#39;&lt;input&gt;&#39; )
		.prop( &#39;type&#39;, &#39;checkbox&#39; )
		.prop( &#39;id&#39;, &#39;sp-ui-jqueryui-tool-&#39; + this.name )
		.prop( &#39;checked&#39;, false );
	this.$label = $( &#39;&lt;label&gt;&#39; )
		.attr( &#39;for&#39;, &#39;sp-ui-jqueryui-tool-&#39; + this.name );

	if ( config.icon ) {
		this.$label
			.addClass( &#39;sp-ui-jqueryui-tool-icon sp-ui-jqueryui-icon-&#39; + config.icon );
	}
	if ( config.label ) {
		this.$label.text( config.label );
	}

	this.$element = $( &#39;&lt;div&gt;&#39; )
		.addClass( &#39;sp-ui-jqueryui-tool sp-ui-jqueryui-tool-checkButtonTool&#39; )
		.append( [ this.$checkbox, this.$label ] );

	// Events
	this.$checkbox.on( &#39;change&#39;, $.proxy( this.onChange , this ) );

	this.$checkbox.button();
};

/* Inheritance */

OO.inheritClass( sp.ui.ext.jqueryui.CheckButtonTool, OO.EventEmitter );

/* Events */

<span id='sp-ui-ext-jqueryui-CheckButtonTool-event-change'>/**
</span> * State change from selected to released
 * @event change
 */

/* Methods */

<span id='sp-ui-ext-jqueryui-CheckButtonTool-method-onChange'>/**
</span> * Respond to a change event
 * @param {jQuery.event} event Click event
 * @fires change
 */
sp.ui.ext.jqueryui.CheckButtonTool.prototype.onChange = function ( event ) {
	var oldValue = this.value;

	this.value = this.$checkbox.prop( &#39;checked&#39; );
	if ( this.value !== oldValue ) {
		this.emit( &#39;change&#39;, this.value );
	}
	event.preventDefault();
};

<span id='sp-ui-ext-jqueryui-CheckButtonTool-method-getValue'>/**
</span> * Return the current value of the button
 * @return {boolean} Checked or unchecked
 */
sp.ui.ext.jqueryui.CheckButtonTool.prototype.getValue = function () {
	return this.value;
};

<span id='sp-ui-ext-jqueryui-CheckButtonTool-method-setValue'>/**
</span> * Set the value of the button
 * @param {[type]} checked [description]
 */
sp.ui.ext.jqueryui.CheckButtonTool.prototype.setValue = function ( checked ) {
	this.value = !!checked;
	this.$checkbox.prop( &#39;checked&#39;, this.value );
	this.$checkbox.button( &#39;refresh&#39; );
};

<span id='sp-ui-ext-jqueryui-LabelTool-method-constructor'><span id='sp-ui-ext-jqueryui-LabelTool'>/**
</span></span> * jQueryUI label.
 *
 * @class
 * @constructor
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.jqueryui.LabelTool = function SpUiExtJqueryUiLabelTool( config ) {
	config = config || {};

	this.$element = $( &#39;&lt;div&gt;&#39; )
		.addClass( &#39;sp-ui-jqueryui-labelTool&#39; );

	this.value = config.value;

	this.$label = $( &#39;&lt;span&gt;&#39; )
		.addClass( &#39;sp-ui-jqueryui-labelTool-label&#39; )
		.text( config.label + &#39;:&#39; )
		.appendTo( this.$element );
	this.$value = $( &#39;&lt;span&gt;&#39; )
		.addClass( &#39;sp-ui-jqueryui-labelTool-value&#39; )
		.text( config.value )
		.appendTo( this.$element );
};

<span id='sp-ui-ext-jqueryui-LabelTool-method-setValue'>/**
</span> * Set value
 * @param {string} value New presented value
 */
sp.ui.ext.jqueryui.LabelTool.prototype.setValue = function ( value ) {
	this.value = value;
	this.$value.text( value );
};

<span id='sp-ui-ext-jqueryui-LabelTool-method-getValue'>/**
</span> * Get value
 */
sp.ui.ext.jqueryui.LabelTool.prototype.getValue = function () {
	return this.value;
};

<span id='sp-ui-ext-jqueryui-SelectTool-method-constructor'><span id='sp-ui-ext-jqueryui-SelectTool'>/**
</span></span> * jQueryUI select tool.
 *
 * @class
 * @constructor
 * @param {Object} [config] Configuration options
 */
sp.ui.ext.jqueryui.SelectTool = function SpUiExtJqueryUiSelectTool( config ) {
	config = config || {};

	// Mixin constructors
	OO.EventEmitter.call( this );

	this.name = config.name || &#39;general&#39;;
	this.action = config.action;

	this.$element = $( &#39;&lt;select&gt;&#39; )
		.prop( &#39;id&#39;, &#39;sp-ui-jqueryui-tool-&#39; + this.name )
		.addClass( &#39;sp-ui-jqueryui-selectTool&#39; );

	this.options = {};
	this.value = &#39;&#39;;

	// Events
	this.$element.on( &#39;change&#39;, $.proxy( this.onChange , this ) );
};

/* Inheritance */

OO.inheritClass( sp.ui.ext.jqueryui.SelectTool, OO.EventEmitter );

<span id='sp-ui-ext-jqueryui-SelectTool-method-onChange'>/**
</span> * Respond to change event
 * @param {jQuery.event} event Change event
 */
sp.ui.ext.jqueryui.SelectTool.prototype.onChange = function ( event, val ) {
	var oldValue = this.value;

	this.value = this.$element.val();
	if ( this.value !== oldValue ) {
		this.emit( &#39;change&#39;, this.value );
	}
};

<span id='sp-ui-ext-jqueryui-SelectTool-method-setValue'>/**
</span> * Select a specific value from the options
 * @param {string} value The value to select
 */
sp.ui.ext.jqueryui.SelectTool.prototype.setValue = function ( value ) {
	if ( this.value !== value ) {
		this.value = value;
		this.$element.val( value );
	}
};

<span id='sp-ui-ext-jqueryui-SelectTool-method-addOption'>/**
</span> * Add an option to the select list
 * @param {string} value The value of the new option
 * @param {string} label The label of the new option
 */
sp.ui.ext.jqueryui.SelectTool.prototype.addOption = function ( value, label ) {
	var option = $( &#39;&lt;option&gt;&#39; )
		.attr( &#39;value&#39;, value )
		.text( label );

	this.options[name] = value;
	this.$element.append( option );
};

<span id='sp-ui-ext-jqueryui-SelectTool-method-removeOption'>/**
</span> * Remove an option from the select list
 * @param {string} value Value of the option to remove
 */
sp.ui.ext.jqueryui.SelectTool.prototype.removeOption = function ( value ) {
	if ( this.options[value] ) {
		delete this.options[value];
		this.$element.find( &#39;option[value=&#39; + value + &#39;]&#39; ).remove();
	}
};

<span id='sp-ui-ext-jqueryui-SelectTool-method-empty'>/**
</span> * Remove all options in the select list
 */
sp.ui.ext.jqueryui.SelectTool.prototype.empty = function () {
	this.$element.empty();
};
</pre>
</body>
</html>
